
########################################################
### test_adept
########################################################

*** Computing numerical adjoint ***

Stack status after numerical adjoint (if recording was successfully
paused then the number of operations should be zero):
Automatic Differentiation Stack (address 0x7ffeecf69948):
   Currently attached - thread unsafe
   Recording status:
      Recording is ON
      19 statements (1048576 allocated) and 23 operations (1048576 allocated)
      5 gradients currently registered and a total of 7 needed (current index 5)
      Gradient list has no gaps
   Computation status:
      0 gradients assigned (0 allocated)
      Jacobian size: 0x0
      Independent indices:
      Dependent indices:  
      Parallel Jacobian calculation not available
Memory usage: 436 bytes

*** Computing adjoint using automatic differentiation ***

Stack status after algorithm run but adjoint not yet computed:
Automatic Differentiation Stack (address 0x7ffeecf69948):
   Currently attached - thread unsafe
   Recording status:
      Recording is ON
      5 statements (1048576 allocated) and 7 operations (1048576 allocated)
      5 gradients currently registered and a total of 7 needed (current index 5)
      Gradient list has no gaps
   Computation status:
      0 gradients assigned (0 allocated)
      Jacobian size: 0x0
      Independent indices:
      Dependent indices:  
      Parallel Jacobian calculation not available
Memory usage: 132 bytes

List of derivative statements:
1: d[5] = 0
2: d[6] =  + 2*d[0] + 9*d[1] + 9*d[1]
3: d[5] =  + 1*d[6]
4: d[5] =  + -0.404038*d[5] + 31.1012*d[6]
5: d[2] =  + 1*d[5]

Initial list of gradients:
0: 0 0 1 0 0 0 0

Final list of gradients:
0: 61.3944 552.55 0 0 0 0 0

*** Computing Jacobian matrix ***

Stack status after adjoint and Jacobian computed:
Automatic Differentiation Stack (address 0x7ffeecf69948):
   Currently attached - thread unsafe
   Recording status:
      Recording is ON
      5 statements (1048576 allocated) and 7 operations (1048576 allocated)
      5 gradients currently registered and a total of 7 needed (current index 5)
      Gradient list has no gaps
   Computation status:
      7 gradients assigned (7 allocated)
      Jacobian size: 1x2
      Independent indices: 0 1
      Dependent indices:   2
      Parallel Jacobian calculation not available
Memory usage: 188 bytes

Result of forward algorithm:
  y = -13.7373
Comparison of gradients:
  dy_dx0[numerical] = 61.3947
  dy_dx0[adjoint]   = 61.3944
  dy_dx0[jacobian]  = 61.3944
  dy_dx1[numerical] = 552.576
  dy_dx1[adjoint]   = 552.55
  dy_dx1[jacobian]  = 552.55

Note that the numerical gradients are less accurate since they use
a finite difference and are also succeptible to round-off error.

########################################################
### test_adept_with_and_without_ad
########################################################

*** Computing numerical adjoint ***

Stack status after numerical adjoint (number of operations should be zero):
Automatic Differentiation Stack (address 0x7ffee1a60910):
   Currently attached - thread unsafe
   Recording status:
      Recording is ON
      2 statements (1048576 allocated) and 0 operations (1048576 allocated)
      3 gradients currently registered and a total of 3 needed (current index 3)
      Gradient list has no gaps
   Computation status:
      0 gradients assigned (0 allocated)
      Jacobian size: 0x0
      Independent indices:
      Dependent indices:  
      Parallel Jacobian calculation not available

*** Computing adjoint using automatic differentiation ***

Stack status after algorithm run but adjoint not yet computed:
Automatic Differentiation Stack (address 0x7ffee1a60910):
   Currently attached - thread unsafe
   Recording status:
      Recording is ON
      5 statements (1048576 allocated) and 7 operations (1048576 allocated)
      3 gradients currently registered and a total of 5 needed (current index 3)
      Gradient list has no gaps
   Computation status:
      0 gradients assigned (0 allocated)
      Jacobian size: 0x0
      Independent indices:
      Dependent indices:  
      Parallel Jacobian calculation not available

List of derivative statements:
1: d[3] = 0
2: d[4] =  + 2*d[0] + 9*d[1] + 9*d[1]
3: d[3] =  + 1*d[4]
4: d[3] =  + -0.404038*d[3] + 31.1012*d[4]
5: d[2] =  + 1*d[3]

Initial list of gradients:
0: 0 0 1 0 0

Final list of gradients:
0: 61.3944 552.55 0 0 0

*** Computing Jacobian matrix ***

Stack status after adjoint and Jacobian computed:
Automatic Differentiation Stack (address 0x7ffee1a60910):
   Currently attached - thread unsafe
   Recording status:
      Recording is ON
      5 statements (1048576 allocated) and 7 operations (1048576 allocated)
      3 gradients currently registered and a total of 5 needed (current index 3)
      Gradient list has no gaps
   Computation status:
      5 gradients assigned (5 allocated)
      Jacobian size: 1x2
      Independent indices: 0 1
      Dependent indices:   2
      Parallel Jacobian calculation not available

Memory usage: 172 bytes

Result of forward algorithm:
  y[from algorithm taking double arguments]  = -13.7373
  y[from algorithm taking adouble arguments] = -13.7373

Comparison of gradients:
  dy_dx0[numerical] = 61.3947
  dy_dx0[adjoint]   = 61.3944
  dy_dx0[jacobian]  = 61.3944
  dy_dx1[numerical] = 552.576
  dy_dx1[adjoint]   = 552.55
  dy_dx1[jacobian]  = 552.55

Note that the numerical gradients are less accurate since they use
a finite difference and are also succeptible to round-off error.

########################################################
### test_radiances
########################################################

Channel 0
d[radiance]/d[surface_temperature] = 6.17433e-06
d[radiance]/d[temperature] = 2.58071e-08 2.28643e-08 2.02477e-08 1.79233e-08 1.586e-08 1.40297e-08 1.24072e-08 1.09697e-08 9.69656e-09 8.56955e-09 7.57224e-09 6.69e-09 5.90977e-09 5.21992e-09 4.61013e-09 4.0712e-09 3.59499e-09 3.17425e-09 2.80258e-09 2.47429e-09 2.18435e-09 1.92831e-09 1.70221e-09 1.50257e-09 1.32631e-09

Channel 1
d[radiance]/d[surface_temperature] = 2.00782e-07
d[radiance]/d[temperature] = 1.03916e-07 1.35583e-07 1.68984e-07 2.02267e-07 2.33612e-07 2.61438e-07 2.84541e-07 3.02164e-07 3.13987e-07 3.20078e-07 3.20811e-07 3.16778e-07 3.08698e-07 2.97343e-07 2.83477e-07 2.67817e-07 2.51005e-07 2.33592e-07 2.16036e-07 1.98702e-07 1.81873e-07 1.65757e-07 1.50499e-07 1.36189e-07 1.22878e-07

Simulated radiances = 0.00186996 0.00141573
Cost function = 1.62251
d[cost_function]/d[surface_temperature] = -0.602936
d[cost_function]/d[temperature] = 0.00558523 0.00837021 0.0112589 0.014109 0.0167805 0.0191519 0.0211313 0.0226611 0.0237183 0.0243102 0.0244678 0.0242391 0.0236819 0.0228581 0.0218289 0.0206515 0.0193773 0.0180502 0.0167069 0.0153767 0.0140825 0.0128409 0.0116637 0.0105585 0.00952944

########################################################
### test_misc
########################################################

x[0] = 2
x[1] = 3
y    = -13.7373
y_ad = 0
x_ad[0]=61.3944
x_ad[1]=552.55

########################################################
### test_checkpoint
########################################################

*** NON-CHECKPOINTED SIMULATION ***
J=26.8688
q_final=[ 1.04034 0.985511 0.927726 0.873141 0.826958 0.792861 0.77287 0.767475 0.775849 0.796055 0.82523 0.85979 0.895727 0.928982 0.955859 0.973389 0.979564 0.97338 0.954725 0.924132 0.88251 0.830927 0.770511 0.702506 0.628429 0.55026 0.470537 0.392253 0.318544 0.252205 0.195237 0.148548 0.111949 0.0843867 0.0643154 0.0500605 0.040075 0.0330707 0.028049 0.0242835 0.0212872 0.0187797 0.016648 0.0148965 0.0135934 0.0128293 0.0127004 0.0133138 0.0148028 0.0173373 0.0211188 0.0263584 0.0332395 0.0418713 0.0522426 0.0641821 0.0773426 0.0912243 0.105254 0.118915 0.131912 0.144305 0.156584 0.169655 0.184742 0.20324 0.226532 0.255772 0.291612 0.333901 0.381416 0.431768 0.481618 0.527245 0.56537 0.593968 0.612765 0.623264 0.628311 0.631397 0.635968 0.644894 0.660175 0.682855 0.713073 0.750216 0.793133 0.840354 0.890267 0.941171 0.991183 1.03805 1.07896 1.11058 1.12936 1.13228 1.11769 1.08606 1.04034 0.985511]
dJ_dq=[ 0.0469906 0.693857 0.882188 1.07574 1.23667 1.35626 1.43203 1.46632 1.46534 1.43805 1.39493 1.34643 1.30169 1.26745 1.24754 1.2428 1.25157 1.2705 1.29548 1.32209 1.34112 1.28553 0.597899 -3.76351 -17.6059 -17.6458 58.8528 -10.6182 -1.29917 -0.757292 5.44846 -4.32112 4.07578 -0.0750411 0.372132 0.25324 0.760983 -0.188971 0.598487 0.283694 -0.253682 -0.0128689 -0.235982 -0.356373 -0.540428 -0.804946 -0.750434 -0.9854 -1.01725 -1.1213 -1.09107 -1.09389 -1.07702 -1.0048 -0.902132 -0.851382 -0.721135 -0.625213 -0.537654 -0.431578 -0.356933 -0.294038 -0.241212 -0.240283 -0.272984 -0.409407 -0.684143 -1.21813 -2.18437 -3.93864 -7.24288 -14.1905 -32.9958 -121.967 -544.472 -76.2148 -24.8867 -9.85118 -3.54755 -0.417025 1.22696 2.05972 2.41012 2.46183 2.32745 2.08036 1.77035 1.43257 1.09307 0.772354 0.487384 0.252453 0.0791122 -0.0243653 -0.053678 -0.00931414 0.102048 0.266337 0.41715 -0.0228831]
Automatic Differentiation Stack (address 0x7ffee7b10b98):
   Currently attached - thread unsafe
   Recording status:
      Recording is ON
      1990201 statements (2097152 allocated) and 8900400 operations (16777216 allocated)
      201 gradients currently registered and a total of 299 needed (current index 201)
      Gradient list has no gaps
   Computation status:
      299 gradients assigned (299 allocated)
      Jacobian size: 0x0
      Independent indices:
      Dependent indices:  
      Parallel Jacobian calculation not available
*** CHECKPOINTED SIMULATION ***
J=26.8688
q_final=[ 1.04034 0.985511 0.927726 0.873141 0.826958 0.792861 0.77287 0.767475 0.775849 0.796055 0.82523 0.85979 0.895727 0.928982 0.955859 0.973389 0.979564 0.97338 0.954725 0.924132 0.88251 0.830927 0.770511 0.702506 0.628429 0.55026 0.470537 0.392253 0.318544 0.252205 0.195237 0.148548 0.111949 0.0843867 0.0643154 0.0500605 0.040075 0.0330707 0.028049 0.0242835 0.0212872 0.0187797 0.016648 0.0148965 0.0135934 0.0128293 0.0127004 0.0133138 0.0148028 0.0173373 0.0211188 0.0263584 0.0332395 0.0418713 0.0522426 0.0641821 0.0773426 0.0912243 0.105254 0.118915 0.131912 0.144305 0.156584 0.169655 0.184742 0.20324 0.226532 0.255772 0.291612 0.333901 0.381416 0.431768 0.481618 0.527245 0.56537 0.593968 0.612765 0.623264 0.628311 0.631397 0.635968 0.644894 0.660175 0.682855 0.713073 0.750216 0.793133 0.840354 0.890267 0.941171 0.991183 1.03805 1.07896 1.11058 1.12936 1.13228 1.11769 1.08606 1.04034 0.985511]
dJ_dq=[ 0.0469906 0.693857 0.882188 1.07574 1.23667 1.35626 1.43203 1.46632 1.46534 1.43805 1.39493 1.34643 1.30169 1.26745 1.24754 1.2428 1.25157 1.2705 1.29548 1.32209 1.34112 1.28553 0.597899 -3.76351 -17.6059 -17.6458 58.8528 -10.6182 -1.29917 -0.757292 5.44846 -4.32112 4.07578 -0.0750411 0.372132 0.25324 0.760983 -0.188971 0.598487 0.283694 -0.253682 -0.0128689 -0.235982 -0.356373 -0.540428 -0.804946 -0.750434 -0.9854 -1.01725 -1.1213 -1.09107 -1.09389 -1.07702 -1.0048 -0.902132 -0.851382 -0.721135 -0.625213 -0.537654 -0.431578 -0.356933 -0.294038 -0.241212 -0.240283 -0.272984 -0.409407 -0.684143 -1.21813 -2.18437 -3.93864 -7.24288 -14.1905 -32.9958 -121.967 -544.472 -76.2148 -24.8867 -9.85118 -3.54755 -0.417025 1.22696 2.05972 2.41012 2.46183 2.32745 2.08036 1.77035 1.43257 1.09307 0.772354 0.487384 0.252453 0.0791122 -0.0243653 -0.053678 -0.00931414 0.102048 0.266337 0.41715 -0.0228831]
Automatic Differentiation Stack (address 0x7ffee7b10b98):
   Currently attached - thread unsafe
   Recording status:
      Recording is ON
      20000 statements (2097152 allocated) and 89100 operations (16777216 allocated)
      10101 gradients currently registered and a total of 10200 needed (current index 10101)
      Gradient list has no gaps
   Computation status:
      10200 gradients assigned (10200 allocated)
      Jacobian size: 0x0
      Independent indices:
      Dependent indices:  
      Parallel Jacobian calculation not available

########################################################
### test_thread_safe
########################################################

Running ./test_thread_safe...
  Compiled to be THREAD UNSAFE
  Compiled with no OpenMP support

*** Iteration 0 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance
Stack status for iteration 0:
Automatic Differentiation Stack (address 0x7ffee7e48510):
   Currently attached - thread unsafe
   Recording status:
      Recording is ON
      510128 statements (1048576 allocated) and 2284128 operations (4194304 allocated)
      256 gradients currently registered and a total of 383 needed (current index 256)
      Gradient list has no gaps
   Computation status:
      0 gradients assigned (0 allocated)
      Jacobian size: 128x128
      Parallel Jacobian calculation not available
Memory usage: 31490568 bytes


*** Iteration 1 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance

*** Iteration 2 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance

*** Iteration 3 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance

*** Iteration 4 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance

*** Iteration 5 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance

*** Iteration 6 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance

*** Iteration 7 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance

*** Iteration 8 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance

*** Iteration 9 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance

*** Iteration 10 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance

*** Iteration 11 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance

*** Iteration 12 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance

*** Iteration 13 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance

*** Iteration 14 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance

*** Iteration 15 (stack address 0x7ffee7e48510):
Used maximum of 1 thread(s) for Jacobian calculation
CORRECT BEHAVIOUR: Jacobians from forward and reverse computations agree within tolerance


########################################################
### test_array_speed
########################################################

Packet<Real>::size = 2
Alignment offset = 0

########################################################
### test_no_lib
########################################################

x[0] = 2
x[1] = 3
y    = -13.7373
y_ad = 0
x_ad[0]=61.3944
x_ad[1]=552.55

########################################################
### test_radiances_array
########################################################

Channel 0
d[radiance]/d[surface_temperature] = 6.17433e-06
d[radiance]/d[temperature] = 2.58071e-08 2.28643e-08 2.02477e-08 1.79233e-08 1.586e-08 1.40297e-08 1.24072e-08 1.09697e-08 9.69656e-09 8.56955e-09 7.57224e-09 6.69e-09 5.90977e-09 5.21992e-09 4.61013e-09 4.0712e-09 3.59499e-09 3.17425e-09 2.80258e-09 2.47429e-09 2.18435e-09 1.92831e-09 1.70221e-09 1.50257e-09 1.32631e-09

Channel 1
d[radiance]/d[surface_temperature] = 2.00782e-07
d[radiance]/d[temperature] = 1.03916e-07 1.35583e-07 1.68984e-07 2.02267e-07 2.33612e-07 2.61438e-07 2.84541e-07 3.02164e-07 3.13987e-07 3.20078e-07 3.20811e-07 3.16778e-07 3.08698e-07 2.97343e-07 2.83477e-07 2.67817e-07 2.51005e-07 2.33592e-07 2.16036e-07 1.98702e-07 1.81873e-07 1.65757e-07 1.50499e-07 1.36189e-07 1.22878e-07

Simulated radiances = 0.00186996 0.00141573
Cost function = 1.62251
d[cost_function]/d[surface_temperature] = -0.602936
d[cost_function]/d[temperature] = 0.00558523 0.00837021 0.0112589 0.014109 0.0167805 0.0191519 0.0211313 0.0226611 0.0237183 0.0243102 0.0244678 0.0242391 0.0236819 0.0228581 0.0218289 0.0206515 0.0193773 0.0180502 0.0167069 0.0153767 0.0140825 0.0128409 0.0116637 0.0105585 0.00952944

########################################################
### test_constructors
########################################################

  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
  running constructor Array(Array&)
####################################################################
COPY CONSTRUCTORS
--------------------------------------------------------------------
Passing Vector as argument to Vector copy constructor
v = {2, 3}
const Vector v2(v)
  running constructor Array(Array&)
v = {2, 3}
v2 = {2, 3}
Verdict for C++98: correct
Verdict for C++11: should perform deep copy
--------------------------------------------------------------------
Passing Vector as argument to const Vector copy constructor
v = {2, 3}
const Vector v_const(v)
  running constructor Array(Array&)
v = {2, 3}
v_const = {2, 3}
Verdict for C++98: correct
Verdict for C++11: should perform deep copy
--------------------------------------------------------------------
Passing const Vector as argument to const Vector copy constructor
v_const = {2, 3}
const Vector v_const2(v_const)
  running constructor Array(const Array&)
v_const = {2, 3}
v_const2 = {2, 3}
Verdict for C++98: correct
Verdict for C++11: should perform deep copy
--------------------------------------------------------------------
Passing const Vector as argument to Vector copy constructor
v_const = {2, 3}
Vector v3(v_const)
  running constructor Array(const Array&)
v_const = {2, 3}
v3 = {2, 3}
Verdict for C++98: should not compile
Verdict for C++11: should perform deep copy
####################################################################
ASSIGNMENT OPERATOR
--------------------------------------------------------------------
Passing Vector to assignment operator
v = {2, 3}
w = v
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
v = {2, 3}
w = {2, 3}
--------------------------------------------------------------------
Passing const Vector to assignment operator
v_const = {5, 7}
w = v_const
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
v_const = {5, 7}
w = {5, 7}
--------------------------------------------------------------------
Passing Vector rvalue to assignment operator
v = {2, 3}
w = v(stride(1,0,-1))
  running Array::operator()(RANGED)
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
v = {2, 3}
w = {3, 2}
--------------------------------------------------------------------
Passing const-Vector rvalue to assignment operator
v_const = {5, 7}
w = v_const(stride(1,0,-1))
  running Array::operator()(RANGED) const
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
v_const = {5, 7}
w = {7, 5}
--------------------------------------------------------------------
Passing Expression to assignment operator
v = {2, 3}
w = v+v
  running Array::operator=(const Expression&)
v = {2, 3}
w = {4, 6}
####################################################################
PASSING Vector TO FUNCTIONS
--------------------------------------------------------------------
Passing Vector as argument to function taking const Vector&
v = {2, 3}
w = square(v)
  inside function
  running constructor Array(const Expression&), implemented by assignment
  running Array::operator=(const Expression&)
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
v = {2, 3}
w = {4, 9}
Verdict for C++98: too many copies
Verdict for C++11: could replace last copy with a move
--------------------------------------------------------------------
Passing Vector as argument to function taking Vector&
v = {2, 3}
square_in_place(v)
  inside function
  running Array::operator=(const Expression&)
v = {4, 9}
Verdict for C++98: correct
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
--------------------------------------------------------------------
Passing Vector as argument to function taking Vector
v = {2, 3}
w = square_copy(v)
  running constructor Array(Array&)
  inside function
  running Array::operator=(const Expression&)
  running constructor Array(const Expression&), implemented by assignment
  running Array::operator=(const Expression&)
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
v = {-2, -3}
w = {4, 9}
Verdict for C++98: too many copies, unexpected change of argument
Verdict for C++11: should do deep copy on input, replace last copy with a move
####################################################################
LINKING
--------------------------------------------------------------------
Linking to Vector
v = {-2, -3}
w >>= v
v = {-2, -3}
w = {-2, -3}
--------------------------------------------------------------------
Linking to Vector rvalue
v = {-2, -3}
w >>= v(stride(1,0,-1))
  running Array::operator()(RANGED)
v = {-2, -3}
w = {-3, -2}
####################################################################
PASSING Vector TO FUNCTIONS
--------------------------------------------------------------------
Passing Vector as argument to function taking const Vector&
v = {-2, -3}
w = square(v)
  inside function
  running constructor Array(const Expression&), implemented by assignment
  running Array::operator=(const Expression&)
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
v = {9, 4}
w = {4, 9}
Verdict for C++98: too many copies
Verdict for C++11: could replace last copy with a move
--------------------------------------------------------------------
Passing Vector as argument to function taking Vector&
v = {9, 4}
square_in_place(v)
  inside function
  running Array::operator=(const Expression&)
v = {81, 16}
Verdict for C++98: correct
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
--------------------------------------------------------------------
Passing Vector as argument to function taking Vector
v = {2, 3}
w = square_copy(v)
  running constructor Array(Array&)
  inside function
  running Array::operator=(const Expression&)
  running constructor Array(const Expression&), implemented by assignment
  running Array::operator=(const Expression&)
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
v = {9, 4}
w = {4, 9}
Verdict for C++98: too many copies, unexpected change of argument
Verdict for C++11: should do deep copy on input, replace last copy with a move
####################################################################
PASSING Vector RVALUE TO FUNCTIONS
--------------------------------------------------------------------
Passing Vector rvalue as argument to function taking const Vector&
v = {9, 4}
w = square(v(stride(1,0,-1)))
  running Array::operator()(RANGED)
  inside function
  running constructor Array(const Expression&), implemented by assignment
  running Array::operator=(const Expression&)
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
v = {81, 16}
w = {16, 81}
Verdict for C++98: correct
--------------------------------------------------------------------
Passing Vector rvalue as argument to function taking Vector&
square_in_place(v(stride(1,0,-1)))
DOES NOT COMPILE (INCORRECT BEHAVIOUR)
Verdict for C++98: Vector subset functions could return references?
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
--------------------------------------------------------------------
Passing Vector rvalue as argument to function taking Vector
v = {2, 3}
w = square_copy(v(stride(1,0,-1)))
  running Array::operator()(RANGED)
  inside function
  running Array::operator=(const Expression&)
  running constructor Array(const Expression&), implemented by assignment
  running Array::operator=(const Expression&)
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
v = {4, 9}
w = {9, 4}
Verdict for C++98: Vector subset functions could return references?
Verdict for C++11: Should use move function
####################################################################
PASSING const Vector RVALUES TO FUNCTIONS
--------------------------------------------------------------------
Passing const-Vector rvalue as argument to function taking const Vector&
v_const = {5, 7}
w = square(v_const(stride(1,0,-1)))
  running Array::operator()(RANGED) const
  inside function
  running constructor Array(const Expression&), implemented by assignment
  running Array::operator=(const Expression&)
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
v_const = {5, 7}
w = {49, 25}
Verdict for C++98: correct
--------------------------------------------------------------------
Passing const-Vector rvalue as argument to function taking Vector
v_const = {5, 7}
w = square_copy(v_const(stride(1,0,-1)))
  running Array::operator()(RANGED) const
  inside function
  running Array::operator=(const Expression&)
  running constructor Array(const Expression&), implemented by assignment
  running Array::operator=(const Expression&)
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
v_const = {-5, -7}
w = {49, 25}
Verdict for C++98: correct
####################################################################
PASSING Expression TO FUNCTIONS
--------------------------------------------------------------------
Passing Expression as argument to function taking const Vector&
v = {25, 49}
w = square(v+v)
  running constructor Array(const Expression&), implemented by assignment
  running Array::operator=(const Expression&)
  inside function
  running constructor Array(const Expression&), implemented by assignment
  running Array::operator=(const Expression&)
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
v = {9604, 2500}
w = {2500, 9604}
Verdict for C++98: Unclear why copy-assignment + constructor needed
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
--------------------------------------------------------------------
Passing Expression as argument to function taking Vector
v = {2, 3}
w = square_copy(v+v)
  running constructor Array(const Expression&), implemented by assignment
  running Array::operator=(const Expression&)
  inside function
  running Array::operator=(const Expression&)
  running constructor Array(const Expression&), implemented by assignment
  running Array::operator=(const Expression&)
  running Array::operator=(const Array&), implemented with operator=(const Expression&)
  running Array::operator=(const Expression&)
  running constructor Array(const Array&)
v = {36, 16}
w = {16, 36}
Verdict for C++98: Unclear why copy-assignment + constructor needed

########################################################
### test_arrays
########################################################

Adept version 2.0.5:
  Compiled with g++ [4.2.1]
  Compiler flags "-g -O2"
  BLAS support from blas library
  Jacobians processed in blocks of size 4
Testing INACTIVE arrays
====================================================================
   TESTING ARRAY FUNCTIONALITY
--------------------------------------------------------------------
### Array "resize" member function
### M.resize(1,5)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M.resize(1,5)
Result: M = 
{{-1.28823e-231, -1.28823e-231, 5, 7, 11}}
--------------------------------------------------------------------
### Array "resize" with invalid dimensions
### M.resize(1)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M.resize(1)
*** Failed with: Invalid dimensions in array resize (in ../include/adept/Array.h:2015)
*** Correct behaviour
--------------------------------------------------------------------
### Array "resize" with "dimensions" function
### M.resize(dimensions(4,2))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M.resize(dimensions(4,2))
Result: M = 
{{-1.28823e-231, -1.28823e-231},
 {1.21791e-152, 4.82336e+228},
 {9.13608e+242, 9.2793e+199},
 {1.65197e-86, 8.47785e+175}}
--------------------------------------------------------------------
### Array "clear" member function
### M.clear()
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M.clear()
Result: M = (empty rank-2 array)
====================================================================
   TESTING BASIC EXPRESSIONS
--------------------------------------------------------------------
### Vector assignment to vector from empty
### v = w
myVector v = (empty rank-1 array)
myVector w = {7, 11, 13}
Evaluating v = w
Result: v = {7, 11, 13}
--------------------------------------------------------------------
### Vector assignment to expression from empty
### v = log(w) + 1.0
myVector v = (empty rank-1 array)
myVector w = {7, 11, 13}
Evaluating v = log(w) + 1.0
Result: v = {2.94591, 3.3979, 3.56495}
--------------------------------------------------------------------
### Matrix *= operator
### M *= 0.5
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M *= 0.5
Result: M = 
{{1, 1.5, 2.5},
 {3.5, 5.5, 6.5}}
--------------------------------------------------------------------
### Matrix = scalar
### M = x
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myReal x = -2
Evaluating M = x
Result: M = 
{{-2, -2, -2},
 {-2, -2, -2}}
--------------------------------------------------------------------
### Matrix = scalar expression
### M = (10.0*x)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myReal x = -2
Evaluating M = (10.0*x)
Result: M = 
{{-20, -20, -20},
 {-20, -20, -20}}
====================================================================
   TESTING BASIC FUNCTIONS
--------------------------------------------------------------------
### max
### v = max(v,w/3.0)
myVector v = {2, 3, 5}
myVector w = {7, 11, 13}
Evaluating v = max(v,w/3.0)
Result: v = {2.33333, 3.66667, 5}
--------------------------------------------------------------------
### min
### v = min(v,w/3.0)
myVector v = {2, 3, 5}
myVector w = {7, 11, 13}
Evaluating v = min(v,w/3.0)
Result: v = {2, 3, 4.33333}
====================================================================
   TESTING ARRAY SLICING
--------------------------------------------------------------------
### Array indexing rvalue
### x = M(1,end-1)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = M(1,end-1)
Result: x = 11
--------------------------------------------------------------------
### Array indexing rvalue out of range (SHOULD FAIL)
### x = M(1,3)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = M(1,3)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Array indexing lvalue
### M(1,end-1) *= -1.0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(1,end-1) *= -1.0
Result: M = 
{{2, 3, 5},
 {7, -11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue
### v = M(__,end)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = M(__,end)
Result: v = {5, 13}
--------------------------------------------------------------------
### contiguous subarray lvalue
### M(end-1,__) /= 2.0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(end-1,__) /= 2.0
Result: M = 
{{1, 1.5, 2.5},
 {7, 11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue and lvalue
### M(__,1) = N(__,2)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M(__,1) = N(__,2)
Result: M = 
{{2, 23, 5},
 {7, 37, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue using range
### v = 2.0 * M(1,range(1,2))
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = 2.0 * M(1,range(1,2))
Result: v = {22, 26}
--------------------------------------------------------------------
### contiguous subarray lvalue using range
### M(end-1,range(0,1)) = log(v(range(1,2)))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector v = {2, 3, 5}
Evaluating M(end-1,range(0,1)) = log(v(range(1,2)))
Result: M = 
{{1.09861, 1.60944, 5},
 {7, 11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue using subset
### M = 2.0 * N.subset(1,1,1,2)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = 2.0 * N.subset(1,1,1,2)
Result: M = 
{{62, 74}}
--------------------------------------------------------------------
### contiguous subarray lvalue using subset
### v.subset(end-1,end) *= 10.0
myVector v = {2, 3, 5}
Evaluating v.subset(end-1,end) *= 10.0
Result: v = {2, 30, 50}
--------------------------------------------------------------------
### regular subarray rvalue
### v = w(stride(end,0,-1))
myVector v = (empty rank-1 array)
myVector w = {7, 11, 13}
Evaluating v = w(stride(end,0,-1))
Result: v = {13, 11, 7}
--------------------------------------------------------------------
### regular subarray lvalue
### M(0,stride(0,end,2)) *= w(stride(end,0,-2))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector w = {7, 11, 13}
Evaluating M(0,stride(0,end,2)) *= w(stride(end,0,-2))
Result: M = 
{{26, 3, 35},
 {7, 11, 13}}
--------------------------------------------------------------------
### irregular subarray rvalue
### M = N(stride(1,0,-1),find(N(0,__)>18))
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = N(stride(1,0,-1),find(N(0,__)>18))
Result: M = 
{{31, 37},
 {19, 23}}
--------------------------------------------------------------------
### irregular subarray lvalue
### M(stride(1,0,-1),find(M(0,__)>4)) = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(stride(1,0,-1),find(M(0,__)>4)) = 0
Result: M = 
{{2, 3, 0},
 {7, 11, 0}}
--------------------------------------------------------------------
### slice leading dimension
### M[end] = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M[end] = 0
Result: M = 
{{2, 3, 5},
 {0, 0, 0}}
--------------------------------------------------------------------
### slice two dimensions
### M[end][0] = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M[end][0] = 0
Result: M = 
{{2, 3, 5},
 {0, 11, 13}}
--------------------------------------------------------------------
### diag_vector member function as rvalue
### v = diag_vector(S,1)
myVector v = (empty rank-1 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = diag_vector(S,1)
Result: v = {3, 13}
--------------------------------------------------------------------
### diag_vector member function as lvalue
### S.diag_vector() += v
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myVector v = {2, 3, 5}
Evaluating S.diag_vector() += v
Result: S = 
{{4, 3, 5},
 {7, 14, 13},
 {17, 19, 28}}
--------------------------------------------------------------------
### diag_matrix member function
### S = v.diag_matrix()
myMatrix S = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating S = v.diag_matrix()
Result: S = 
{{2, 0, 0},
 {0, 3, 0},
 {0, 0, 5}}
--------------------------------------------------------------------
### diag_matrix external function
### S = diag_matrix(v)
myMatrix S = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating S = diag_matrix(v)
Result: S = 
{{2, 0, 0},
 {0, 3, 0},
 {0, 0, 5}}
--------------------------------------------------------------------
### transpose as rvalue via T member function
### N = 2.0 * M.T()
myMatrix N = (empty rank-2 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating N = 2.0 * M.T()
Result: N = 
{{4, 14},
 {6, 22},
 {10, 26}}
--------------------------------------------------------------------
### transpose as rvalue via permute member function
### N = 2.0 * M.permute(1,0)
myMatrix N = (empty rank-2 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating N = 2.0 * M.permute(1,0)
Result: N = 
{{4, 14},
 {6, 22},
 {10, 26}}
--------------------------------------------------------------------
### matrix indexing (scalar,non-contiguous)
### v = N(1,index)
myVector v = (empty rank-1 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating v = N(1,index)
Result: v = {31, 29}
--------------------------------------------------------------------
### matrix indexing (non-contiguous,scalar)
### v = N(index,1)
myVector v = (empty rank-1 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating v = N(index,1)
Result: v = {31, 19}
--------------------------------------------------------------------
### 2D arbitrary index as rvalue
### M = const_cast<const myMatrix&>(N)(index,index)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating M = const_cast<const myMatrix&>(N)(index,index)
Result: M = 
{{31, 29},
 {19, 17}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue assigned to scalar expression
### M(index,index) = 2.0*(myReal)(4.0)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating M(index,index) = 2.0*(myReal)(4.0)
Result: M = 
{{8, 8, 5},
 {8, 8, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue
### M(index,index) = N(__,range(1,2))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating M(index,index) = N(__,range(1,2))
Result: M = 
{{37, 31, 5},
 {23, 19, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with assign-multiply operator
### M(index,index) *= 10.0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
intVector index = {1, 0}
Evaluating M(index,index) *= 10.0
Result: M = 
{{20, 30, 5},
 {70, 110, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with aliased right-hand-side
### M(index,index) = M(__,range(0,1))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
intVector index = {1, 0}
Evaluating M(index,index) = M(__,range(0,1))
Result: M = 
{{11, 7, 5},
 {3, 2, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with aliased right-hand-side and eval function
### M(index,index) = eval(M(__,range(0,1)))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
intVector index = {1, 0}
Evaluating M(index,index) = eval(M(__,range(0,1)))
Result: M = 
{{11, 7, 5},
 {3, 2, 13}}
--------------------------------------------------------------------
### reshape member function
### M >>= vlong.reshape(3,4)
myMatrix M = (empty rank-2 array)
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating M >>= vlong.reshape(3,4)
Result: M = 
{{1, 2, 3, 4},
 {5, 6, 7, 8},
 {9, 10, 11, 12}}
--------------------------------------------------------------------
### reshape member function with invalid dimensions
### M >>= vlong.reshape(5,5)
myMatrix M = (empty rank-2 array)
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating M >>= vlong.reshape(5,5)
*** Failed with: Size of reshaped array does not match original vector
*** Correct behaviour
--------------------------------------------------------------------
### end/2 indexing
### vlong(range(end/2,end)) = 0.0
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating vlong(range(end/2,end)) = 0.0
Result: vlong = {1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0}
--------------------------------------------------------------------
### end/2 indexing
### vlong(range(0,end/2)) = 0.0
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating vlong(range(0,end/2)) = 0.0
Result: vlong = {0, 0, 0, 0, 0, 0, 7, 8, 9, 10, 11, 12}
--------------------------------------------------------------------
### end/2 indexing
### vlong.subset(end/2,end) = 0.0
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating vlong.subset(end/2,end) = 0.0
Result: vlong = {1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0}
====================================================================
   TESTING REDUCTION OPERATIONS
--------------------------------------------------------------------
### full sum
### x = sum(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = sum(M)
Result: x = 41
--------------------------------------------------------------------
### full product
### x = product(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = product(M)
Result: x = 30030
--------------------------------------------------------------------
### full maxval
### x = maxval(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = maxval(M)
Result: x = 13
--------------------------------------------------------------------
### full minval
### x = minval(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = minval(M)
Result: x = 2
--------------------------------------------------------------------
### full norm2
### x = norm2(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = norm2(M)
Result: x = 19.4165
--------------------------------------------------------------------
### 1-dimension mean
### v = 0.5 * mean(M,0)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = 0.5 * mean(M,0)
Result: v = {2.25, 3.5, 4.5}
--------------------------------------------------------------------
### 1-dimension norm2
### v = norm2(M,1)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = norm2(M,1)
Result: v = {6.16441, 18.412}
--------------------------------------------------------------------
### dot product
### x = dot_product(w,w(stride(end,0,-1)))
myReal x = -2
myVector w = {7, 11, 13}
Evaluating x = dot_product(w,w(stride(end,0,-1)))
Result: x = 303
--------------------------------------------------------------------
### dot product on expressions
### x = dot_product(2.0*w,w(stride(end,0,-1))+1.0)
myReal x = -2
myVector w = {7, 11, 13}
Evaluating x = dot_product(2.0*w,w(stride(end,0,-1))+1.0)
Result: x = 668
--------------------------------------------------------------------
### 1-dimension maxval
### v = maxval(M,1)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = maxval(M,1)
Result: v = {5, 13}
--------------------------------------------------------------------
### 1-dimension minval
### v = minval(M,1)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = minval(M,1)
Result: v = {2, 7}
--------------------------------------------------------------------
### 1D interpolation
### v = interp(value(v), w, Vector(value(w)/3.0))
myVector v = {2, 3, 5}
myVector w = {7, 11, 13}
Evaluating v = interp(value(v), w, Vector(value(w)/3.0))
Result: v = {8.33333, 11.6667, 12.3333}
--------------------------------------------------------------------
### 1D interpolation
### v = interp(value(v), w, value(w)/3.0)
myVector v = {2, 3, 5}
myVector w = {7, 11, 13}
Evaluating v = interp(value(v), w, value(w)/3.0)
Result: v = {8.33333, 11.6667, 12.3333}
--------------------------------------------------------------------
### all reduction
### b = all(M > 8.0)
bool b = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating b = all(M > 8.0)
Result: b = 0
--------------------------------------------------------------------
### any reduction
### b = any(M > 8.0)
bool b = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating b = any(M > 8.0)
Result: b = 1
--------------------------------------------------------------------
### count reduction
### c = count(M > 8.0)
int c = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating c = count(M > 8.0)
Result: c = 2
--------------------------------------------------------------------
### 1-dimension all reduction
### B = all(M > 8.0, 1)
boolVector B = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating B = all(M > 8.0, 1)
Result: B = {0, 0}
--------------------------------------------------------------------
### 1-dimension any reduction
### B = any(M > 8.0, 1)
boolVector B = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating B = any(M > 8.0, 1)
Result: B = {0, 1}
--------------------------------------------------------------------
### 1-dimension count reduction
### index = count(M > 8.0, 1)
intVector index = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating index = count(M > 8.0, 1)
Result: index = {0, 2}
====================================================================
   TESTING CONDITIONAL OPERATIONS
--------------------------------------------------------------------
### where construct, scalar right-hand-side
### M.where(N > 20) = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = 0
Result: M = 
{{2, 3, 0},
 {0, 0, 0}}
--------------------------------------------------------------------
### where construct, expression right-hand-side
### M.where(N > 20) = -N
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = -N
Result: M = 
{{2, 3, -23},
 {-29, -31, -37}}
--------------------------------------------------------------------
### where construct, scalar either-or right-hand-side
### M.where(N > 20) = either_or(0,1)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = either_or(0,1)
Result: M = 
{{1, 1, 0},
 {0, 0, 0}}
--------------------------------------------------------------------
### where construct, expression either-or right-hand-side
### M.where(N > 20) = either_or(-N,N)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = either_or(-N,N)
Result: M = 
{{17, 19, -23},
 {-29, -31, -37}}
--------------------------------------------------------------------
### find construct, scalar right-hand-side
### v(find(v > 3.5)) = 0
myVector v = {2, 3, 5}
Evaluating v(find(v > 3.5)) = 0
Result: v = {2, 3, 0}
--------------------------------------------------------------------
### find construct, expression right-hand-side
### v(find(v > 3.5)) = -v(range(end,end))
myVector v = {2, 3, 5}
Evaluating v(find(v > 3.5)) = -v(range(end,end))
Result: v = {2, 3, -5}
--------------------------------------------------------------------
### find construct, multiply-assign right-hand-side
### v(find(v != 5.0)) *= 10.0
myVector v = {2, 3, 5}
Evaluating v(find(v != 5.0)) *= 10.0
Result: v = {20, 30, 5}
====================================================================
   TESTING SPECIAL SQUARE MATRICES
--------------------------------------------------------------------
### SymmMatrix "resize" member function
### O.resize(5)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.resize(5)
Result: O = 
{{-1.28823e-231, -1.28823e-231, -1.28823e-231, 5, -1.28823e-231},
 {-1.28823e-231, 3, -1.28823e-231, 3, -1.28823e-231},
 {-1.28823e-231, -1.28823e-231, 3, 5, -1.28823e-231},
 {5, 3, 5, 13, -1.28823e-231},
 {-1.28823e-231, -1.28823e-231, -1.28823e-231, -1.28823e-231, 12.3333}}
--------------------------------------------------------------------
### SymmMatrix "resize" with invalid dimensions
### O.resize(4,5)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.resize(4,5)
*** Failed with: Square matrix must have the same x and y dimensions (in ../include/adept/SpecialMatrix.h:1527)
*** Correct behaviour
--------------------------------------------------------------------
### SymmMatrix "clear" member function
### O.clear()
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.clear()
Result: O = (empty rank-2 array)
--------------------------------------------------------------------
### SymmMatrix assign from dense matrix
### O = S
mySymmMatrix O = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating O = S
Result: O = 
{{2, 7, 17},
 {7, 11, 19},
 {17, 19, 23}}
--------------------------------------------------------------------
### DiagMatrix assign from dense matrix
### D = S
myDiagMatrix D = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating D = S
Result: D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### TridiagMatrix assign from dense matrix
### T = S
myTridiagMatrix T = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating T = S
Result: T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
--------------------------------------------------------------------
### LowerMatrix assign from dense matrix
### L = S
myLowerMatrix L = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating L = S
Result: L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
--------------------------------------------------------------------
### UpperMatrix assign from dense matrix
### U = S
myUpperMatrix U = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating U = S
Result: U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
--------------------------------------------------------------------
### SymmMatrix += operator
### O += 3.0
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O += 3.0
Result: O = 
{{10, 5, 6},
 {5, 14, 8},
 {6, 8, 16}}
--------------------------------------------------------------------
### DiagMatrix += operator
### D += 3.0
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating D += 3.0
Result: D = 
{{5, 0, 0},
 {0, 14, 0},
 {0, 0, 26}}
--------------------------------------------------------------------
### TridiagMatrix += operator
### T += 3.0
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating T += 3.0
Result: T = 
{{5, 6, 0},
 {10, 14, 16},
 {0, 22, 26}}
--------------------------------------------------------------------
### LowerMatrix += operator
### L += 3.0
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating L += 3.0
Result: L = 
{{5, 0, 0},
 {10, 14, 0},
 {20, 22, 26}}
--------------------------------------------------------------------
### UpperMatrix += operator
### U += 3.0
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating U += 3.0
Result: U = 
{{5, 6, 8},
 {0, 14, 16},
 {0, 0, 26}}
--------------------------------------------------------------------
### SymmMatrix as rvalue
### M = O
myMatrix M = (empty rank-2 array)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating M = O
Result: M = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
--------------------------------------------------------------------
### DiagMatrix as rvalue
### M = D
myMatrix M = (empty rank-2 array)
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating M = D
Result: M = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### TridiagMatrix as rvalue
### M = T
myMatrix M = (empty rank-2 array)
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating M = T
Result: M = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
--------------------------------------------------------------------
### LowerMatrix as rvalue
### M = L
myMatrix M = (empty rank-2 array)
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating M = L
Result: M = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
--------------------------------------------------------------------
### UpperMatrix as rvalue
### M = U
myMatrix M = (empty rank-2 array)
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating M = U
Result: M = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
--------------------------------------------------------------------
### SymmMatrix assign from scalar expression
### O = 2.0*(myReal)(4.0)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O = 2.0*(myReal)(4.0)
Result: O = 
{{8, 8, 8},
 {8, 8, 8},
 {8, 8, 8}}
--------------------------------------------------------------------
### UpperMatrix assign from scalar expression
### U = 2.0*(myReal)(4.0)
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating U = 2.0*(myReal)(4.0)
Result: U = 
{{8, 8, 8},
 {0, 8, 8},
 {0, 0, 8}}
--------------------------------------------------------------------
### SymmMatrix diag_vector member function as lvalue (upper)
### O.diag_vector(1) = 0
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.diag_vector(1) = 0
Result: O = 
{{7, 0, 3},
 {0, 11, 0},
 {3, 0, 13}}
--------------------------------------------------------------------
### SymmMatrix diag_vector member function as lvalue (lower)
### O.diag_vector(-2) += 10.0
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.diag_vector(-2) += 10.0
Result: O = 
{{7, 2, 13},
 {2, 11, 5},
 {13, 5, 13}}
--------------------------------------------------------------------
### DiagMatrix diag_vector member function as lvalue
### D.diag_vector() = 0.0
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating D.diag_vector() = 0.0
Result: D = 
{{0, 0, 0},
 {0, 0, 0},
 {0, 0, 0}}
--------------------------------------------------------------------
### DiagMatrix diag_vector member function incorrectly using offdiagonal
### D.diag_vector(1) = 0.0
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating D.diag_vector(1) = 0.0
*** Failed with: Attempt to get lvalue diagonal to off-diagonal in BandMatrix (in ../include/adept/SpecialMatrix.h:350)
*** Correct behaviour
--------------------------------------------------------------------
### TridiagMatrix diag_vector member function as lvalue (upper)
### T.diag_vector(1) += 10.0
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating T.diag_vector(1) += 10.0
Result: T = 
{{2, 13, 0},
 {7, 11, 23},
 {0, 19, 23}}
--------------------------------------------------------------------
### TridiagMatrix diag_vector member function as lvalue (lower)
### T.diag_vector(-1) = 0.0
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating T.diag_vector(-1) = 0.0
Result: T = 
{{2, 3, 0},
 {0, 11, 13},
 {0, 0, 23}}
--------------------------------------------------------------------
### LowerMatrix diag_vector member function as lvalue (lower)
### L.diag_vector(-1) = 0.0
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating L.diag_vector(-1) = 0.0
Result: L = 
{{2, 0, 0},
 {0, 11, 0},
 {17, 0, 23}}
--------------------------------------------------------------------
### LowerMatrix diag_vector member function as lvalue (upper)
### L.diag_vector(1) = 0.0
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating L.diag_vector(1) = 0.0
*** Failed with: Attempt to get lvalue to an upper diagonal of a lower-triangular matrix (in ../include/adept/SpecialMatrix.h:683)
*** Correct behaviour
--------------------------------------------------------------------
### UpperMatrix diag_vector member function as lvalue (lower)
### U.diag_vector(-1) = 0.0
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating U.diag_vector(-1) = 0.0
*** Failed with: Attempt to get lvalue to a lower diagonal of an upper-triangular matrix (in ../include/adept/SpecialMatrix.h:810)
*** Correct behaviour
--------------------------------------------------------------------
### UpperMatrix diag_vector member function as lvalue (upper)
### U.diag_vector(1) = 0.0
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating U.diag_vector(1) = 0.0
Result: U = 
{{2, 0, 5},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(1) = -1.0
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.diag_vector(1) = -1.0
Result: Q = 
{{3, -1, 0, 0, 0},
 {2, 3, -1, 0, 0},
 {1, 2, 3, -1, 0},
 {0, 1, 2, 3, -1},
 {0, 0, 1, 2, 3}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(0) = -1.0
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.diag_vector(0) = -1.0
Result: Q = 
{{-1, 4, 0, 0, 0},
 {2, -1, 4, 0, 0},
 {1, 2, -1, 4, 0},
 {0, 1, 2, -1, 4},
 {0, 0, 1, 2, -1}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(-1) = -1.0
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.diag_vector(-1) = -1.0
Result: Q = 
{{3, 4, 0, 0, 0},
 {-1, 3, 4, 0, 0},
 {1, -1, 3, 4, 0},
 {0, 1, -1, 3, 4},
 {0, 0, 1, -1, 3}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(-2) = -1.0
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.diag_vector(-2) = -1.0
Result: Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {-1, 2, 3, 4, 0},
 {0, -1, 2, 3, 4},
 {0, 0, -1, 2, 3}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function
### M = S.submatrix_on_diagonal(1,2)
myMatrix M = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating M = S.submatrix_on_diagonal(1,2)
Result: M = 
{{11, 13},
 {19, 23}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function as lvalue
### S.submatrix_on_diagonal(0,1) = 0.0
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating S.submatrix_on_diagonal(0,1) = 0.0
Result: S = 
{{0, 0, 5},
 {0, 0, 13},
 {17, 19, 23}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function to non-square matrix
### M = N.submatrix_on_diagonal(1,2)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = N.submatrix_on_diagonal(1,2)
*** Failed with: submatrix_on_diagonal member function only applicable to square matrices (in ../include/adept/Array.h:1586)
*** Correct behaviour
--------------------------------------------------------------------
### SymmMatrix submatrix_on_diagonal member function
### P = O.submatrix_on_diagonal(1,2)
mySymmMatrix P = (empty rank-2 array)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating P = O.submatrix_on_diagonal(1,2)
Result: P = 
{{11, 5},
 {5, 13}}
--------------------------------------------------------------------
### DiagMatrix submatrix_on_diagonal member function
### E = D.submatrix_on_diagonal(1,2)
myDiagMatrix E = (empty rank-2 array)
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating E = D.submatrix_on_diagonal(1,2)
Result: E = 
{{11, 0},
 {0, 23}}
--------------------------------------------------------------------
### TridiagMatrix submatrix_on_diagonal member function
### TT = T.submatrix_on_diagonal(1,2)
myTridiagMatrix TT = (empty rank-2 array)
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating TT = T.submatrix_on_diagonal(1,2)
Result: TT = 
{{11, 13},
 {19, 23}}
--------------------------------------------------------------------
### LowerMatrix submatrix_on_diagonal member function
### LL = L.submatrix_on_diagonal(1,2)
myLowerMatrix LL = (empty rank-2 array)
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating LL = L.submatrix_on_diagonal(1,2)
Result: LL = 
{{11, 0},
 {19, 23}}
--------------------------------------------------------------------
### UpperMatrix submatrix_on_diagonal member function
### UU = U.submatrix_on_diagonal(1,2)
myUpperMatrix UU = (empty rank-2 array)
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating UU = U.submatrix_on_diagonal(1,2)
Result: UU = 
{{11, 13},
 {0, 23}}
--------------------------------------------------------------------
### Odd band matrix submatrix_on_diagonal member function
### R = Q.submatrix_on_diagonal(1,3)
myOddBandMatrix R = (empty rank-2 array)
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating R = Q.submatrix_on_diagonal(1,3)
Result: R = 
{{3, 4, 0},
 {2, 3, 4},
 {1, 2, 3}}
--------------------------------------------------------------------
### Odd band matrix submatrix_on_diagonal as lvalue
### Q.submatrix_on_diagonal(1,3) = -1
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.submatrix_on_diagonal(1,3) = -1
Result: Q = 
{{3, 4, 0, 0, 0},
 {2, -1, -1, 0, 0},
 {1, -1, -1, -1, 0},
 {0, -1, -1, -1, 4},
 {0, 0, 1, 2, 3}}
--------------------------------------------------------------------
### SymmMatrix transpose as rvalue via T member function
### P = O.T()
mySymmMatrix P = (empty rank-2 array)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating P = O.T()
Result: P = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
--------------------------------------------------------------------
### DiagMatrix transpose as rvalue via T member function
### E = D.T()
myDiagMatrix E = (empty rank-2 array)
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating E = D.T()
Result: E = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### TridiagMatrix transpose as rvalue via T member function
### TT = T.T()
myTridiagMatrix TT = (empty rank-2 array)
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating TT = T.T()
Result: TT = 
{{2, 7, 0},
 {3, 11, 19},
 {0, 13, 23}}
--------------------------------------------------------------------
### LowerMatrix transpose as rvalue via T member function
### U = L.T()
myUpperMatrix U = (empty rank-2 array)
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating U = L.T()
Result: U = 
{{2, 7, 17},
 {0, 11, 19},
 {0, 0, 23}}
--------------------------------------------------------------------
### UpperMatrix transpose as rvalue via T member function
### L = U.T()
myLowerMatrix L = (empty rank-2 array)
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating L = U.T()
Result: L = 
{{2, 0, 0},
 {3, 11, 0},
 {5, 13, 23}}
====================================================================
   TESTING EXPANSION OPERATIONS
--------------------------------------------------------------------
### Outer product
### M = outer_product(v,v)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = outer_product(v,v)
Result: M = 
{{4, 6, 10},
 {6, 9, 15},
 {10, 15, 25}}
--------------------------------------------------------------------
### Outer product on indexed array
### M = outer_product(v,v(stride(end,0,-1)))
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = outer_product(v,v(stride(end,0,-1)))
Result: M = 
{{10, 6, 4},
 {15, 9, 6},
 {25, 15, 10}}
--------------------------------------------------------------------
### Outer product on expressions
### M = outer_product(2.0*v,v-1.0)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = outer_product(2.0*v,v-1.0)
Result: M = 
{{4, 8, 16},
 {6, 12, 24},
 {10, 20, 40}}
--------------------------------------------------------------------
### Vector spread of dimension 0
### M = spread<0>(v,2)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = spread<0>(v,2)
Result: M = 
{{2, 3, 5},
 {2, 3, 5}}
--------------------------------------------------------------------
### Vector spread of dimension 1
### M = spread<1>(v,2)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = spread<1>(v,2)
Result: M = 
{{2, 2},
 {3, 3},
 {5, 5}}
--------------------------------------------------------------------
### Vector spread with expression argument
### M = spread<1>(v*2.0,2)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = spread<1>(v*2.0,2)
Result: M = 
{{4, 4},
 {6, 6},
 {10, 10}}
--------------------------------------------------------------------
### Matrix spread of dimension 0
### A = spread<0>(M,2)
myArray3D A = (empty rank-3 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating A = spread<0>(M,2)
Result: A = 
{{{2, 3, 5},
  {7, 11, 13}},
 {{2, 3, 5},
  {7, 11, 13}}}
--------------------------------------------------------------------
### Matrix spread of dimension 1
### A = spread<1>(M,2)
myArray3D A = (empty rank-3 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating A = spread<1>(M,2)
Result: A = 
{{{2, 3, 5},
  {2, 3, 5}},
 {{7, 11, 13},
  {7, 11, 13}}}
--------------------------------------------------------------------
### Matrix spread of dimension 2
### A = spread<2>(M,2)
myArray3D A = (empty rank-3 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating A = spread<2>(M,2)
Result: A = 
{{{2, 2},
  {3, 3},
  {5, 5}},
 {{7, 7},
  {11, 11},
  {13, 13}}}
====================================================================
   TESTING MATRIX MULTIPLICATION
--------------------------------------------------------------------
### Matrix-Vector multiplication
### w = M ** v
myVector w = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector v = {2, 3, 5}
Evaluating w = M ** v
Result: w = {38, 112}
--------------------------------------------------------------------
### Matrix-Vector multiplication with strided matrix
### w = Mstrided ** v
myVector w = (empty rank-1 array)
myMatrix Mstrided = 
{{2, 3, 5},
 {7, 11, 13}}
myVector v = {2, 3, 5}
Evaluating w = Mstrided ** v
Result: w = {38, 112}
--------------------------------------------------------------------
### Matrix-Matrix multiplication
### M = N.T() ** N
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = N.T() ** N
Result: M = 
{{1130, 1222, 1464},
 {1222, 1322, 1584},
 {1464, 1584, 1898}}
--------------------------------------------------------------------
### Matrix-Matrix multiplication with matmul
### M = matmul(N.T(), N)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = matmul(N.T(), N)
Result: M = 
{{1130, 1222, 1464},
 {1222, 1322, 1584},
 {1464, 1584, 1898}}
--------------------------------------------------------------------
### Matrix-Matrix multiplication with inner dimension mismatch
### M = N ** N
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = N ** N
*** Failed with: Inner dimension mismatch in array multiplication (in ../include/adept/matmul.h:36)
*** Correct behaviour
--------------------------------------------------------------------
### Matrix-Matrix-Vector multiplication
### v = S ** S ** v
myVector v = {2, 3, 5}
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = S ** S ** v
Result: v = {1442, 4176, 7512}
--------------------------------------------------------------------
### Matrix-Matrix-Vector multiplication
### v = S ** log(S) ** S(0,__)
myVector v = (empty rank-1 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = S ** log(S) ** S(0,__)
Result: v = {248.075, 744.422, 1364.77}
--------------------------------------------------------------------
### Vector-Matrix multiplication
### v = v ** S
myVector v = {2, 3, 5}
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = v ** S
Result: v = {110, 134, 164}
--------------------------------------------------------------------
### Vector-Matrix multiplication with matmul
### v = matmul(v, S)
myVector v = {2, 3, 5}
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = matmul(v, S)
Result: v = {110, 134, 164}
--------------------------------------------------------------------
### SymmMatrix-Vector multiplication
### v = O ** v
myVector v = {2, 3, 5}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating v = O ** v
Result: v = {35, 62, 86}
--------------------------------------------------------------------
### SymmMatrix-Matrix multiplication
### S = O ** S
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating S = O ** S
Result: S = 
{{79, 100, 130},
 {166, 222, 268},
 {262, 311, 379}}
--------------------------------------------------------------------
### Vector-SymmMatrix multiplication
### v = v ** O
myVector v = {2, 3, 5}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating v = v ** O
Result: v = {35, 62, 86}
--------------------------------------------------------------------
### Matrix-SymmMatrix multiplication
### M = M ** O
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating M = M ** O
Result: M = 
{{35, 62, 86},
 {110, 200, 245}}
--------------------------------------------------------------------
### DiagMatrix-Vector multiplication
### v = D ** v
myVector v = {2, 3, 5}
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating v = D ** v
Result: v = {4, 33, 115}
--------------------------------------------------------------------
### TridiagMatrix-Vector multiplication
### v = T ** v
myVector v = {2, 3, 5}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating v = T ** v
Result: v = {13, 112, 172}
--------------------------------------------------------------------
### TridiagMatrix-Matrix multiplication
### S = T ** S
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating S = T ** S
Result: S = 
{{25, 39, 49},
 {312, 389, 477},
 {524, 646, 776}}
--------------------------------------------------------------------
### LowerMatrix-Matrix multiplication
### S = L ** S
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating S = L ** S
Result: S = 
{{4, 6, 10},
 {91, 142, 178},
 {558, 697, 861}}
--------------------------------------------------------------------
### Vector-TridiagMatrix multiplication
### v = v ** T
myVector v = {2, 3, 5}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating v = v ** T
Result: v = {25, 134, 154}
--------------------------------------------------------------------
### Matrix-TridiagMatrix multiplication
### M = M ** T
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating M = M ** T
Result: M = 
{{25, 134, 154},
 {91, 389, 442}}
====================================================================
   TESTING LINEAR ALGEBRA
--------------------------------------------------------------------
### Solving general linear equations Ax=b
### v = solve(S,v)
myVector v = {2, 3, 5}
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = solve(S,v)
Result: v = {-0.128205, -0.615385, 0.820513}
--------------------------------------------------------------------
### Solving general linear equations Ax=b with expression arguments
### v = solve(S,2*v)
myVector v = {2, 3, 5}
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = solve(S,2*v)
Result: v = {-0.25641, -1.23077, 1.64103}
--------------------------------------------------------------------
### Solving general linear equations AX=B
### M.T() = solve(S,M.T())
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating M.T() = solve(S,M.T())
Result: M = 
{{-0.128205, -0.615385, 0.820513},
 {-1.53846, -1.38462, 2.84615}}
--------------------------------------------------------------------
### Solving general linear equations AX=B with expression arguments
### M.T() = solve(2.0 * S,2.0 * M.T())
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating M.T() = solve(2.0 * S,2.0 * M.T())
Result: M = 
{{-0.128205, -0.615385, 0.820513},
 {-1.53846, -1.38462, 2.84615}}
--------------------------------------------------------------------
### Solving linear equations Ax=b with symmetric A
### v = solve(O,v)
myVector v = {2, 3, 5}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating v = solve(O,v)
Result: v = {0.119728, 0.107483, 0.315646}
--------------------------------------------------------------------
### Solving linear equations AX=B with symmetric A
### M.T() = solve(O,M.T())
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating M.T() = solve(O,M.T())
Result: M = 
{{0.119728, 0.107483, 0.315646},
 {0.552381, 0.609524, 0.638095}}
--------------------------------------------------------------------
### Solving linear equations AX=B with symmetric A and B
### S = solve(O,P)
myMatrix S = (empty rank-2 array)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
mySymmMatrix P = 
{{7, 12, 11},
 {12, 3, 9},
 {11, 9, 1}}
Evaluating S = solve(O,P)
Result: S = 
{{0.6, 1.6, 1.6},
 {0.8, -0.2, 0.8},
 {0.4, 0.4, -0.6}}
--------------------------------------------------------------------
### Solving linear equations Ax=b with upper-triangular A
### v = solve(U,v)
myVector v = {2, 3, 5}
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating v = solve(U,v)
Result: v = {0.432806, 0.0158103, 0.217391}
--------------------------------------------------------------------
### Invert general matrix
### M = inv(S)
myMatrix M = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating M = inv(S)
Result: M = 
{{-0.0769231, -0.333333, 0.205128},
 {-0.769231, 0.5, -0.115385},
 {0.692308, -0.166667, -0.0128205}}
--------------------------------------------------------------------
### Invert symmetric matrix
### P = inv(O)
mySymmMatrix P = (empty rank-2 array)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating P = inv(O)
Result: P = 
{{0.160544, -0.014966, -0.0312925},
 {-0.014966, 0.111565, -0.0394558},
 {-0.0312925, -0.0394558, 0.0993197}}
====================================================================
   TESTING FILLING ARRAYS
--------------------------------------------------------------------
### Fill vector with "<<"
### (v << 0.1, 0.2)
myVector v = {2, 3, 5}
Evaluating (v << 0.1, 0.2)
Result: v = {0.1, 0.2, 5}
--------------------------------------------------------------------
### Overfill vector with "<<"
### (v << 0.1, 0.2, 0.3, 0.4)
myVector v = {2, 3, 5}
Evaluating (v << 0.1, 0.2, 0.3, 0.4)
*** Failed with: Row overflow in filling Vector with "<<" (in ../include/adept/Allocator.h:132)
*** Correct behaviour
--------------------------------------------------------------------
### Underfill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5)
Result: M = 
{{0.1, 0.2, 0.3},
 {0.4, 0.5, 13}}
--------------------------------------------------------------------
### Fill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6)
Result: M = 
{{0.1, 0.2, 0.3},
 {0.4, 0.5, 0.6}}
--------------------------------------------------------------------
### Overfill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
*** Failed with: Dimension overflow in filling array with "<<" (in ../include/adept/Allocator.h:154)
*** Correct behaviour
--------------------------------------------------------------------
### Fill vector with vectors using "<<"
### v << v(range(1,2)) << 0.1
myVector v = {2, 3, 5}
Evaluating v << v(range(1,2)) << 0.1
Result: v = {3, 5, 0.1}
--------------------------------------------------------------------
### Fill matrix with vector using "<<"
### M << 0.1 << 0.2 << 0.3 << v
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector v = {2, 3, 5}
Evaluating M << 0.1 << 0.2 << 0.3 << v
Result: M = 
{{0.1, 0.2, 0.3},
 {2, 3, 5}}
--------------------------------------------------------------------
### Fill matrix with vector using "<<"
### S << v << v << v
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myVector v = {2, 3, 5}
Evaluating S << v << v << v
Result: S = 
{{2, 3, 5},
 {2, 3, 5},
 {2, 3, 5}}
--------------------------------------------------------------------
### Assign array using range
### v = range(3,6)
myVector v = (empty rank-1 array)
Evaluating v = range(3,6)
Result: v = {3, 4, 5, 6}
====================================================================
   TESTING PRINTING WITH PLAIN STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
(empty rank-1 array)
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
2 3 5
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'
2 3 5
7 11 13
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'
2 3
5 7
11 13
17 19
23 29
31 37
====================================================================
   TESTING PRINTING WITH CSV STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
empty
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
2, 3, 5
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'
2, 3, 5
7, 11, 13
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'
2, 3
5, 7
11, 13
17, 19
23, 29
31, 37
====================================================================
   TESTING PRINTING WITH CURLY STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
(empty rank-1 array)
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
{2, 3, 5}
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'

{{2, 3, 5},
 {7, 11, 13}}
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'

{{{2, 3},
  {5, 7},
  {11, 13}},
 {{17, 19},
  {23, 29},
  {31, 37}}}
====================================================================
   TESTING PRINTING WITH MATLAB STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
[]
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
[2 3 5]
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'
[2 3 5;
 7 11 13]
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'
[2 3;
 5 7;
 11 13;
 17 19;
 23 29;
 31 37]
====================================================================
   TESTING EXPRESSION PRINTING
--------------------------------------------------------------------
### Send expression to standard output
### std::cout << M(0,__) + M(1,__) << '\n'
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating std::cout << M(0,__) + M(1,__) << '\n'
{9, 14, 18}
Result: M = 
{{2, 3, 5},
 {7, 11, 13}}
--------------------------------------------------------------------
### Send scalar expression to standard output
### std::cout << v(0) + v(1) << '\n'
myVector v = {2, 3, 5}
Evaluating std::cout << v(0) + v(1) << '\n'
5
Result: v = {2, 3, 5}
====================================================================
   TESTING BOUNDS CHECKING
--------------------------------------------------------------------
### Access vector out of bounds
### v(0) = v(4)
myVector v = {2, 3, 5}
Evaluating v(0) = v(4)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Access vector out of bounds
### v(0) = v(end-4)
myVector v = {2, 3, 5}
Evaluating v(0) = v(end-4)
*** Failed with: Array index (probably generated from a scalar expression containing "end") is out of bounds (in ../include/adept/RangeIndex.h:128)
*** Correct behaviour
--------------------------------------------------------------------
### Access matrix out of bounds
### M(0,0) = M(0,-1)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(0,0) = M(0,-1)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Access matrix out of bounds
### M(0,0) = M(end+1,1)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(0,0) = M(end+1,1)
*** Failed with: Array index (probably generated from a scalar expression containing "end") is out of bounds (in ../include/adept/RangeIndex.h:128)
*** Correct behaviour
====================================================================
In terms of run-time errors, all tests were passed

########################################################
### test_arrays_active
########################################################

Adept version 2.0.5:
  Compiled with g++ [4.2.1]
  Compiler flags "-g -O2"
  BLAS support from blas library
  Jacobians processed in blocks of size 4
Testing ACTIVE arrays
====================================================================
   TESTING ARRAY FUNCTIONALITY
--------------------------------------------------------------------
### Array "resize" member function
### M.resize(1,5)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M.resize(1,5)
Result: M = 
{{-0, -0, 5, 7, 11}}
--------------------------------------------------------------------
### Array "resize" with invalid dimensions
### M.resize(1)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M.resize(1)
*** Failed with: Invalid dimensions in array resize (in ../include/adept/Array.h:2015)
*** Correct behaviour
--------------------------------------------------------------------
### Array "resize" with "dimensions" function
### M.resize(dimensions(4,2))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M.resize(dimensions(4,2))
Result: M = 
{{-0, -0},
 {1.21791e-152, 4.82336e+228},
 {9.13608e+242, 9.2793e+199},
 {1.65197e-86, 8.47785e+175}}
--------------------------------------------------------------------
### Array "clear" member function
### M.clear()
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M.clear()
Result: M = (empty rank-2 array)
====================================================================
   TESTING BASIC EXPRESSIONS
--------------------------------------------------------------------
### Vector assignment to vector from empty
### v = w
myVector v = (empty rank-1 array)
myVector w = {7, 11, 13}
Evaluating v = w
Result: v = {7, 11, 13}
--------------------------------------------------------------------
### Vector assignment to expression from empty
### v = log(w) + 1.0
myVector v = (empty rank-1 array)
myVector w = {7, 11, 13}
Evaluating v = log(w) + 1.0
Result: v = {2.94591, 3.3979, 3.56495}
--------------------------------------------------------------------
### Matrix *= operator
### M *= 0.5
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M *= 0.5
Result: M = 
{{1, 1.5, 2.5},
 {3.5, 5.5, 6.5}}
--------------------------------------------------------------------
### Matrix = scalar
### M = x
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myReal x = -2
Evaluating M = x
Result: M = 
{{-2, -2, -2},
 {-2, -2, -2}}
--------------------------------------------------------------------
### Matrix = scalar expression
### M = (10.0*x)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myReal x = -2
Evaluating M = (10.0*x)
Result: M = 
{{-20, -20, -20},
 {-20, -20, -20}}
====================================================================
   TESTING BASIC FUNCTIONS
--------------------------------------------------------------------
### max
### v = max(v,w/3.0)
myVector v = {2, 3, 5}
myVector w = {7, 11, 13}
Evaluating v = max(v,w/3.0)
Result: v = {2.33333, 3.66667, 5}
--------------------------------------------------------------------
### min
### v = min(v,w/3.0)
myVector v = {2, 3, 5}
myVector w = {7, 11, 13}
Evaluating v = min(v,w/3.0)
Result: v = {2, 3, 4.33333}
====================================================================
   TESTING ARRAY SLICING
--------------------------------------------------------------------
### Array indexing rvalue
### x = M(1,end-1)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = M(1,end-1)
Result: x = 11
--------------------------------------------------------------------
### Array indexing rvalue out of range (SHOULD FAIL)
### x = M(1,3)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = M(1,3)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Array indexing lvalue
### M(1,end-1) *= -1.0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(1,end-1) *= -1.0
Result: M = 
{{2, 3, 5},
 {7, -11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue
### v = M(__,end)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = M(__,end)
Result: v = {5, 13}
--------------------------------------------------------------------
### contiguous subarray lvalue
### M(end-1,__) /= 2.0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(end-1,__) /= 2.0
Result: M = 
{{1, 1.5, 2.5},
 {7, 11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue and lvalue
### M(__,1) = N(__,2)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M(__,1) = N(__,2)
Result: M = 
{{2, 23, 5},
 {7, 37, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue using range
### v = 2.0 * M(1,range(1,2))
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = 2.0 * M(1,range(1,2))
Result: v = {22, 26}
--------------------------------------------------------------------
### contiguous subarray lvalue using range
### M(end-1,range(0,1)) = log(v(range(1,2)))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector v = {2, 3, 5}
Evaluating M(end-1,range(0,1)) = log(v(range(1,2)))
Result: M = 
{{1.09861, 1.60944, 5},
 {7, 11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue using subset
### M = 2.0 * N.subset(1,1,1,2)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = 2.0 * N.subset(1,1,1,2)
Result: M = 
{{62, 74}}
--------------------------------------------------------------------
### contiguous subarray lvalue using subset
### v.subset(end-1,end) *= 10.0
myVector v = {2, 3, 5}
Evaluating v.subset(end-1,end) *= 10.0
Result: v = {2, 30, 50}
--------------------------------------------------------------------
### regular subarray rvalue
### v = w(stride(end,0,-1))
myVector v = (empty rank-1 array)
myVector w = {7, 11, 13}
Evaluating v = w(stride(end,0,-1))
Result: v = {13, 11, 7}
--------------------------------------------------------------------
### regular subarray lvalue
### M(0,stride(0,end,2)) *= w(stride(end,0,-2))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector w = {7, 11, 13}
Evaluating M(0,stride(0,end,2)) *= w(stride(end,0,-2))
Result: M = 
{{26, 3, 35},
 {7, 11, 13}}
--------------------------------------------------------------------
### irregular subarray rvalue
### M = N(stride(1,0,-1),find(N(0,__)>18))
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = N(stride(1,0,-1),find(N(0,__)>18))
Result: M = 
{{31, 37},
 {19, 23}}
--------------------------------------------------------------------
### irregular subarray lvalue
### M(stride(1,0,-1),find(M(0,__)>4)) = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(stride(1,0,-1),find(M(0,__)>4)) = 0
Result: M = 
{{2, 3, 0},
 {7, 11, 0}}
--------------------------------------------------------------------
### slice leading dimension
### M[end] = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M[end] = 0
Result: M = 
{{2, 3, 5},
 {0, 0, 0}}
--------------------------------------------------------------------
### slice two dimensions
### M[end][0] = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M[end][0] = 0
Result: M = 
{{2, 3, 5},
 {0, 11, 13}}
--------------------------------------------------------------------
### diag_vector member function as rvalue
### v = diag_vector(S,1)
myVector v = (empty rank-1 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = diag_vector(S,1)
Result: v = {3, 13}
--------------------------------------------------------------------
### diag_vector member function as lvalue
### S.diag_vector() += v
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myVector v = {2, 3, 5}
Evaluating S.diag_vector() += v
Result: S = 
{{4, 3, 5},
 {7, 14, 13},
 {17, 19, 28}}
--------------------------------------------------------------------
### diag_matrix member function
### S = v.diag_matrix()
myMatrix S = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating S = v.diag_matrix()
Result: S = 
{{2, 0, 0},
 {0, 3, 0},
 {0, 0, 5}}
--------------------------------------------------------------------
### diag_matrix external function
### S = diag_matrix(v)
myMatrix S = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating S = diag_matrix(v)
Result: S = 
{{2, 0, 0},
 {0, 3, 0},
 {0, 0, 5}}
--------------------------------------------------------------------
### transpose as rvalue via T member function
### N = 2.0 * M.T()
myMatrix N = (empty rank-2 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating N = 2.0 * M.T()
Result: N = 
{{4, 14},
 {6, 22},
 {10, 26}}
--------------------------------------------------------------------
### transpose as rvalue via permute member function
### N = 2.0 * M.permute(1,0)
myMatrix N = (empty rank-2 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating N = 2.0 * M.permute(1,0)
Result: N = 
{{4, 14},
 {6, 22},
 {10, 26}}
--------------------------------------------------------------------
### matrix indexing (scalar,non-contiguous)
### v = N(1,index)
myVector v = (empty rank-1 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating v = N(1,index)
Result: v = {31, 29}
--------------------------------------------------------------------
### matrix indexing (non-contiguous,scalar)
### v = N(index,1)
myVector v = (empty rank-1 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating v = N(index,1)
Result: v = {31, 19}
--------------------------------------------------------------------
### 2D arbitrary index as rvalue
### M = const_cast<const myMatrix&>(N)(index,index)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating M = const_cast<const myMatrix&>(N)(index,index)
Result: M = 
{{31, 29},
 {19, 17}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue assigned to scalar expression
### M(index,index) = 2.0*(myReal)(4.0)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating M(index,index) = 2.0*(myReal)(4.0)
Result: M = 
{{8, 8, 5},
 {8, 8, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue
### M(index,index) = N(__,range(1,2))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating M(index,index) = N(__,range(1,2))
Result: M = 
{{37, 31, 5},
 {23, 19, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with assign-multiply operator
### M(index,index) *= 10.0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
intVector index = {1, 0}
Evaluating M(index,index) *= 10.0
Result: M = 
{{20, 30, 5},
 {70, 110, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with aliased right-hand-side
### M(index,index) = M(__,range(0,1))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
intVector index = {1, 0}
Evaluating M(index,index) = M(__,range(0,1))
Result: M = 
{{11, 7, 5},
 {3, 2, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with aliased right-hand-side and eval function
### M(index,index) = eval(M(__,range(0,1)))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
intVector index = {1, 0}
Evaluating M(index,index) = eval(M(__,range(0,1)))
Result: M = 
{{11, 7, 5},
 {3, 2, 13}}
--------------------------------------------------------------------
### reshape member function
### M >>= vlong.reshape(3,4)
myMatrix M = (empty rank-2 array)
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating M >>= vlong.reshape(3,4)
Result: M = 
{{1, 2, 3, 4},
 {5, 6, 7, 8},
 {9, 10, 11, 12}}
--------------------------------------------------------------------
### reshape member function with invalid dimensions
### M >>= vlong.reshape(5,5)
myMatrix M = (empty rank-2 array)
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating M >>= vlong.reshape(5,5)
*** Failed with: Size of reshaped array does not match original vector
*** Correct behaviour
--------------------------------------------------------------------
### end/2 indexing
### vlong(range(end/2,end)) = 0.0
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating vlong(range(end/2,end)) = 0.0
Result: vlong = {1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0}
--------------------------------------------------------------------
### end/2 indexing
### vlong(range(0,end/2)) = 0.0
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating vlong(range(0,end/2)) = 0.0
Result: vlong = {0, 0, 0, 0, 0, 0, 7, 8, 9, 10, 11, 12}
--------------------------------------------------------------------
### end/2 indexing
### vlong.subset(end/2,end) = 0.0
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating vlong.subset(end/2,end) = 0.0
Result: vlong = {1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0}
====================================================================
   TESTING REDUCTION OPERATIONS
--------------------------------------------------------------------
### full sum
### x = sum(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = sum(M)
Result: x = 41
--------------------------------------------------------------------
### full product
### x = product(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = product(M)
Result: x = 30030
--------------------------------------------------------------------
### full maxval
### x = maxval(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = maxval(M)
Result: x = 13
--------------------------------------------------------------------
### full minval
### x = minval(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = minval(M)
Result: x = 2
--------------------------------------------------------------------
### full norm2
### x = norm2(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = norm2(M)
Result: x = 19.4165
--------------------------------------------------------------------
### 1-dimension mean
### v = 0.5 * mean(M,0)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = 0.5 * mean(M,0)
Result: v = {2.25, 3.5, 4.5}
--------------------------------------------------------------------
### 1-dimension norm2
### v = norm2(M,1)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = norm2(M,1)
Result: v = {6.16441, 18.412}
--------------------------------------------------------------------
### dot product
### x = dot_product(w,w(stride(end,0,-1)))
myReal x = -2
myVector w = {7, 11, 13}
Evaluating x = dot_product(w,w(stride(end,0,-1)))
Result: x = 303
--------------------------------------------------------------------
### dot product on expressions
### x = dot_product(2.0*w,w(stride(end,0,-1))+1.0)
myReal x = -2
myVector w = {7, 11, 13}
Evaluating x = dot_product(2.0*w,w(stride(end,0,-1))+1.0)
Result: x = 668
--------------------------------------------------------------------
### 1-dimension maxval
### v = maxval(M,1)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = maxval(M,1)
Result: v = {5, 13}
--------------------------------------------------------------------
### 1-dimension minval
### v = minval(M,1)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = minval(M,1)
Result: v = {2, 7}
--------------------------------------------------------------------
### 1D interpolation
### v = interp(value(v), w, Vector(value(w)/3.0))
myVector v = {2, 3, 5}
myVector w = {7, 11, 13}
Evaluating v = interp(value(v), w, Vector(value(w)/3.0))
Result: v = {8.33333, 11.6667, 12.3333}
--------------------------------------------------------------------
### 1D interpolation
### v = interp(value(v), w, value(w)/3.0)
myVector v = {2, 3, 5}
myVector w = {7, 11, 13}
Evaluating v = interp(value(v), w, value(w)/3.0)
Result: v = {8.33333, 11.6667, 12.3333}
--------------------------------------------------------------------
### all reduction
### b = all(M > 8.0)
bool b = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating b = all(M > 8.0)
Result: b = 0
--------------------------------------------------------------------
### any reduction
### b = any(M > 8.0)
bool b = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating b = any(M > 8.0)
Result: b = 1
--------------------------------------------------------------------
### count reduction
### c = count(M > 8.0)
int c = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating c = count(M > 8.0)
Result: c = 2
--------------------------------------------------------------------
### 1-dimension all reduction
### B = all(M > 8.0, 1)
boolVector B = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating B = all(M > 8.0, 1)
Result: B = {0, 0}
--------------------------------------------------------------------
### 1-dimension any reduction
### B = any(M > 8.0, 1)
boolVector B = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating B = any(M > 8.0, 1)
Result: B = {0, 1}
--------------------------------------------------------------------
### 1-dimension count reduction
### index = count(M > 8.0, 1)
intVector index = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating index = count(M > 8.0, 1)
Result: index = {0, 2}
====================================================================
   TESTING CONDITIONAL OPERATIONS
--------------------------------------------------------------------
### where construct, scalar right-hand-side
### M.where(N > 20) = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = 0
Result: M = 
{{2, 3, 0},
 {0, 0, 0}}
--------------------------------------------------------------------
### where construct, expression right-hand-side
### M.where(N > 20) = -N
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = -N
Result: M = 
{{2, 3, -23},
 {-29, -31, -37}}
--------------------------------------------------------------------
### where construct, scalar either-or right-hand-side
### M.where(N > 20) = either_or(0,1)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = either_or(0,1)
Result: M = 
{{1, 1, 0},
 {0, 0, 0}}
--------------------------------------------------------------------
### where construct, expression either-or right-hand-side
### M.where(N > 20) = either_or(-N,N)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = either_or(-N,N)
Result: M = 
{{17, 19, -23},
 {-29, -31, -37}}
--------------------------------------------------------------------
### find construct, scalar right-hand-side
### v(find(v > 3.5)) = 0
myVector v = {2, 3, 5}
Evaluating v(find(v > 3.5)) = 0
Result: v = {2, 3, 0}
--------------------------------------------------------------------
### find construct, expression right-hand-side
### v(find(v > 3.5)) = -v(range(end,end))
myVector v = {2, 3, 5}
Evaluating v(find(v > 3.5)) = -v(range(end,end))
Result: v = {2, 3, -5}
--------------------------------------------------------------------
### find construct, multiply-assign right-hand-side
### v(find(v != 5.0)) *= 10.0
myVector v = {2, 3, 5}
Evaluating v(find(v != 5.0)) *= 10.0
Result: v = {20, 30, 5}
====================================================================
   TESTING SPECIAL SQUARE MATRICES
--------------------------------------------------------------------
### SymmMatrix "resize" member function
### O.resize(5)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.resize(5)
Result: O = 
{{-0, -0, -0, 5, -0},
 {-0, 3, -0, 3, -0},
 {-0, -0, 3, 5, -1.4822e-323},
 {5, 3, 5, 13, -0},
 {-0, -0, -1.4822e-323, -0, 12.3333}}
--------------------------------------------------------------------
### SymmMatrix "resize" with invalid dimensions
### O.resize(4,5)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.resize(4,5)
*** Failed with: Square matrix must have the same x and y dimensions (in ../include/adept/SpecialMatrix.h:1527)
*** Correct behaviour
--------------------------------------------------------------------
### SymmMatrix "clear" member function
### O.clear()
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.clear()
Result: O = (empty rank-2 array)
--------------------------------------------------------------------
### SymmMatrix assign from dense matrix
### O = S
mySymmMatrix O = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating O = S
Result: O = 
{{2, 7, 17},
 {7, 11, 19},
 {17, 19, 23}}
--------------------------------------------------------------------
### DiagMatrix assign from dense matrix
### D = S
myDiagMatrix D = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating D = S
Result: D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### TridiagMatrix assign from dense matrix
### T = S
myTridiagMatrix T = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating T = S
Result: T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
--------------------------------------------------------------------
### LowerMatrix assign from dense matrix
### L = S
myLowerMatrix L = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating L = S
Result: L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
--------------------------------------------------------------------
### UpperMatrix assign from dense matrix
### U = S
myUpperMatrix U = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating U = S
Result: U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
--------------------------------------------------------------------
### SymmMatrix += operator
### O += 3.0
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O += 3.0
Result: O = 
{{10, 5, 6},
 {5, 14, 8},
 {6, 8, 16}}
--------------------------------------------------------------------
### DiagMatrix += operator
### D += 3.0
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating D += 3.0
Result: D = 
{{5, 0, 0},
 {0, 14, 0},
 {0, 0, 26}}
--------------------------------------------------------------------
### TridiagMatrix += operator
### T += 3.0
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating T += 3.0
Result: T = 
{{5, 6, 0},
 {10, 14, 16},
 {0, 22, 26}}
--------------------------------------------------------------------
### LowerMatrix += operator
### L += 3.0
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating L += 3.0
Result: L = 
{{5, 0, 0},
 {10, 14, 0},
 {20, 22, 26}}
--------------------------------------------------------------------
### UpperMatrix += operator
### U += 3.0
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating U += 3.0
Result: U = 
{{5, 6, 8},
 {0, 14, 16},
 {0, 0, 26}}
--------------------------------------------------------------------
### SymmMatrix as rvalue
### M = O
myMatrix M = (empty rank-2 array)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating M = O
Result: M = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
--------------------------------------------------------------------
### DiagMatrix as rvalue
### M = D
myMatrix M = (empty rank-2 array)
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating M = D
Result: M = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### TridiagMatrix as rvalue
### M = T
myMatrix M = (empty rank-2 array)
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating M = T
Result: M = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
--------------------------------------------------------------------
### LowerMatrix as rvalue
### M = L
myMatrix M = (empty rank-2 array)
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating M = L
Result: M = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
--------------------------------------------------------------------
### UpperMatrix as rvalue
### M = U
myMatrix M = (empty rank-2 array)
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating M = U
Result: M = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
--------------------------------------------------------------------
### SymmMatrix assign from scalar expression
### O = 2.0*(myReal)(4.0)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O = 2.0*(myReal)(4.0)
Result: O = 
{{8, 8, 8},
 {8, 8, 8},
 {8, 8, 8}}
--------------------------------------------------------------------
### UpperMatrix assign from scalar expression
### U = 2.0*(myReal)(4.0)
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating U = 2.0*(myReal)(4.0)
Result: U = 
{{8, 8, 8},
 {0, 8, 8},
 {0, 0, 8}}
--------------------------------------------------------------------
### SymmMatrix diag_vector member function as lvalue (upper)
### O.diag_vector(1) = 0
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.diag_vector(1) = 0
Result: O = 
{{7, 0, 3},
 {0, 11, 0},
 {3, 0, 13}}
--------------------------------------------------------------------
### SymmMatrix diag_vector member function as lvalue (lower)
### O.diag_vector(-2) += 10.0
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.diag_vector(-2) += 10.0
Result: O = 
{{7, 2, 13},
 {2, 11, 5},
 {13, 5, 13}}
--------------------------------------------------------------------
### DiagMatrix diag_vector member function as lvalue
### D.diag_vector() = 0.0
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating D.diag_vector() = 0.0
Result: D = 
{{0, 0, 0},
 {0, 0, 0},
 {0, 0, 0}}
--------------------------------------------------------------------
### DiagMatrix diag_vector member function incorrectly using offdiagonal
### D.diag_vector(1) = 0.0
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating D.diag_vector(1) = 0.0
*** Failed with: Attempt to get lvalue diagonal to off-diagonal in BandMatrix (in ../include/adept/SpecialMatrix.h:350)
*** Correct behaviour
--------------------------------------------------------------------
### TridiagMatrix diag_vector member function as lvalue (upper)
### T.diag_vector(1) += 10.0
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating T.diag_vector(1) += 10.0
Result: T = 
{{2, 13, 0},
 {7, 11, 23},
 {0, 19, 23}}
--------------------------------------------------------------------
### TridiagMatrix diag_vector member function as lvalue (lower)
### T.diag_vector(-1) = 0.0
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating T.diag_vector(-1) = 0.0
Result: T = 
{{2, 3, 0},
 {0, 11, 13},
 {0, 0, 23}}
--------------------------------------------------------------------
### LowerMatrix diag_vector member function as lvalue (lower)
### L.diag_vector(-1) = 0.0
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating L.diag_vector(-1) = 0.0
Result: L = 
{{2, 0, 0},
 {0, 11, 0},
 {17, 0, 23}}
--------------------------------------------------------------------
### LowerMatrix diag_vector member function as lvalue (upper)
### L.diag_vector(1) = 0.0
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating L.diag_vector(1) = 0.0
*** Failed with: Attempt to get lvalue to an upper diagonal of a lower-triangular matrix (in ../include/adept/SpecialMatrix.h:683)
*** Correct behaviour
--------------------------------------------------------------------
### UpperMatrix diag_vector member function as lvalue (lower)
### U.diag_vector(-1) = 0.0
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating U.diag_vector(-1) = 0.0
*** Failed with: Attempt to get lvalue to a lower diagonal of an upper-triangular matrix (in ../include/adept/SpecialMatrix.h:810)
*** Correct behaviour
--------------------------------------------------------------------
### UpperMatrix diag_vector member function as lvalue (upper)
### U.diag_vector(1) = 0.0
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating U.diag_vector(1) = 0.0
Result: U = 
{{2, 0, 5},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(1) = -1.0
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.diag_vector(1) = -1.0
Result: Q = 
{{3, -1, 0, 0, 0},
 {2, 3, -1, 0, 0},
 {1, 2, 3, -1, 0},
 {0, 1, 2, 3, -1},
 {0, 0, 1, 2, 3}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(0) = -1.0
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.diag_vector(0) = -1.0
Result: Q = 
{{-1, 4, 0, 0, 0},
 {2, -1, 4, 0, 0},
 {1, 2, -1, 4, 0},
 {0, 1, 2, -1, 4},
 {0, 0, 1, 2, -1}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(-1) = -1.0
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.diag_vector(-1) = -1.0
Result: Q = 
{{3, 4, 0, 0, 0},
 {-1, 3, 4, 0, 0},
 {1, -1, 3, 4, 0},
 {0, 1, -1, 3, 4},
 {0, 0, 1, -1, 3}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(-2) = -1.0
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.diag_vector(-2) = -1.0
Result: Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {-1, 2, 3, 4, 0},
 {0, -1, 2, 3, 4},
 {0, 0, -1, 2, 3}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function
### M = S.submatrix_on_diagonal(1,2)
myMatrix M = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating M = S.submatrix_on_diagonal(1,2)
Result: M = 
{{11, 13},
 {19, 23}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function as lvalue
### S.submatrix_on_diagonal(0,1) = 0.0
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating S.submatrix_on_diagonal(0,1) = 0.0
Result: S = 
{{0, 0, 5},
 {0, 0, 13},
 {17, 19, 23}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function to non-square matrix
### M = N.submatrix_on_diagonal(1,2)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = N.submatrix_on_diagonal(1,2)
*** Failed with: submatrix_on_diagonal member function only applicable to square matrices (in ../include/adept/Array.h:1586)
*** Correct behaviour
--------------------------------------------------------------------
### SymmMatrix submatrix_on_diagonal member function
### P = O.submatrix_on_diagonal(1,2)
mySymmMatrix P = (empty rank-2 array)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating P = O.submatrix_on_diagonal(1,2)
Result: P = 
{{11, 5},
 {5, 13}}
--------------------------------------------------------------------
### DiagMatrix submatrix_on_diagonal member function
### E = D.submatrix_on_diagonal(1,2)
myDiagMatrix E = (empty rank-2 array)
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating E = D.submatrix_on_diagonal(1,2)
Result: E = 
{{11, 0},
 {0, 23}}
--------------------------------------------------------------------
### TridiagMatrix submatrix_on_diagonal member function
### TT = T.submatrix_on_diagonal(1,2)
myTridiagMatrix TT = (empty rank-2 array)
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating TT = T.submatrix_on_diagonal(1,2)
Result: TT = 
{{11, 13},
 {19, 23}}
--------------------------------------------------------------------
### LowerMatrix submatrix_on_diagonal member function
### LL = L.submatrix_on_diagonal(1,2)
myLowerMatrix LL = (empty rank-2 array)
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating LL = L.submatrix_on_diagonal(1,2)
Result: LL = 
{{11, 0},
 {19, 23}}
--------------------------------------------------------------------
### UpperMatrix submatrix_on_diagonal member function
### UU = U.submatrix_on_diagonal(1,2)
myUpperMatrix UU = (empty rank-2 array)
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating UU = U.submatrix_on_diagonal(1,2)
Result: UU = 
{{11, 13},
 {0, 23}}
--------------------------------------------------------------------
### Odd band matrix submatrix_on_diagonal member function
### R = Q.submatrix_on_diagonal(1,3)
myOddBandMatrix R = (empty rank-2 array)
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating R = Q.submatrix_on_diagonal(1,3)
Result: R = 
{{3, 4, 0},
 {2, 3, 4},
 {1, 2, 3}}
--------------------------------------------------------------------
### Odd band matrix submatrix_on_diagonal as lvalue
### Q.submatrix_on_diagonal(1,3) = -1
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.submatrix_on_diagonal(1,3) = -1
Result: Q = 
{{3, 4, 0, 0, 0},
 {2, -1, -1, 0, 0},
 {1, -1, -1, -1, 0},
 {0, -1, -1, -1, 4},
 {0, 0, 1, 2, 3}}
--------------------------------------------------------------------
### SymmMatrix transpose as rvalue via T member function
### P = O.T()
mySymmMatrix P = (empty rank-2 array)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating P = O.T()
Result: P = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
--------------------------------------------------------------------
### DiagMatrix transpose as rvalue via T member function
### E = D.T()
myDiagMatrix E = (empty rank-2 array)
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating E = D.T()
Result: E = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### TridiagMatrix transpose as rvalue via T member function
### TT = T.T()
myTridiagMatrix TT = (empty rank-2 array)
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating TT = T.T()
Result: TT = 
{{2, 7, 0},
 {3, 11, 19},
 {0, 13, 23}}
--------------------------------------------------------------------
### LowerMatrix transpose as rvalue via T member function
### U = L.T()
myUpperMatrix U = (empty rank-2 array)
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating U = L.T()
Result: U = 
{{2, 7, 17},
 {0, 11, 19},
 {0, 0, 23}}
--------------------------------------------------------------------
### UpperMatrix transpose as rvalue via T member function
### L = U.T()
myLowerMatrix L = (empty rank-2 array)
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating L = U.T()
Result: L = 
{{2, 0, 0},
 {3, 11, 0},
 {5, 13, 23}}
====================================================================
   TESTING EXPANSION OPERATIONS
--------------------------------------------------------------------
### Outer product
### M = outer_product(v,v)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = outer_product(v,v)
Result: M = 
{{4, 6, 10},
 {6, 9, 15},
 {10, 15, 25}}
--------------------------------------------------------------------
### Outer product on indexed array
### M = outer_product(v,v(stride(end,0,-1)))
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = outer_product(v,v(stride(end,0,-1)))
Result: M = 
{{10, 6, 4},
 {15, 9, 6},
 {25, 15, 10}}
--------------------------------------------------------------------
### Outer product on expressions
### M = outer_product(2.0*v,v-1.0)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = outer_product(2.0*v,v-1.0)
Result: M = 
{{4, 8, 16},
 {6, 12, 24},
 {10, 20, 40}}
--------------------------------------------------------------------
### Vector spread of dimension 0
### M = spread<0>(v,2)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = spread<0>(v,2)
Result: M = 
{{2, 3, 5},
 {2, 3, 5}}
--------------------------------------------------------------------
### Vector spread of dimension 1
### M = spread<1>(v,2)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = spread<1>(v,2)
Result: M = 
{{2, 2},
 {3, 3},
 {5, 5}}
--------------------------------------------------------------------
### Vector spread with expression argument
### M = spread<1>(v*2.0,2)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = spread<1>(v*2.0,2)
Result: M = 
{{4, 4},
 {6, 6},
 {10, 10}}
--------------------------------------------------------------------
### Matrix spread of dimension 0
### A = spread<0>(M,2)
myArray3D A = (empty rank-3 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating A = spread<0>(M,2)
Result: A = 
{{{2, 3, 5},
  {7, 11, 13}},
 {{2, 3, 5},
  {7, 11, 13}}}
--------------------------------------------------------------------
### Matrix spread of dimension 1
### A = spread<1>(M,2)
myArray3D A = (empty rank-3 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating A = spread<1>(M,2)
Result: A = 
{{{2, 3, 5},
  {2, 3, 5}},
 {{7, 11, 13},
  {7, 11, 13}}}
--------------------------------------------------------------------
### Matrix spread of dimension 2
### A = spread<2>(M,2)
myArray3D A = (empty rank-3 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating A = spread<2>(M,2)
Result: A = 
{{{2, 2},
  {3, 3},
  {5, 5}},
 {{7, 7},
  {11, 11},
  {13, 13}}}
====================================================================
   TESTING MATRIX MULTIPLICATION
--------------------------------------------------------------------
### Matrix-Vector multiplication
### w = M ** v
myVector w = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector v = {2, 3, 5}
Evaluating w = M ** v
Result: w = {38, 112}
--------------------------------------------------------------------
### Matrix-Vector multiplication with strided matrix
### w = Mstrided ** v
myVector w = (empty rank-1 array)
myMatrix Mstrided = 
{{2, 3, 5},
 {7, 11, 13}}
myVector v = {2, 3, 5}
Evaluating w = Mstrided ** v
Result: w = {38, 112}
--------------------------------------------------------------------
### Matrix-Matrix multiplication
### M = N.T() ** N
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = N.T() ** N
Result: M = 
{{1130, 1222, 1464},
 {1222, 1322, 1584},
 {1464, 1584, 1898}}
--------------------------------------------------------------------
### Matrix-Matrix multiplication with matmul
### M = matmul(N.T(), N)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = matmul(N.T(), N)
Result: M = 
{{1130, 1222, 1464},
 {1222, 1322, 1584},
 {1464, 1584, 1898}}
--------------------------------------------------------------------
### Matrix-Matrix multiplication with inner dimension mismatch
### M = N ** N
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = N ** N
*** Failed with: Inner dimension mismatch in array multiplication (in ../include/adept/matmul.h:36)
*** Correct behaviour
--------------------------------------------------------------------
### Matrix-Matrix-Vector multiplication
### v = S ** S ** v
myVector v = {2, 3, 5}
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = S ** S ** v
Result: v = {1442, 4176, 7512}
--------------------------------------------------------------------
### Matrix-Matrix-Vector multiplication
### v = S ** log(S) ** S(0,__)
myVector v = (empty rank-1 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = S ** log(S) ** S(0,__)
Result: v = {248.075, 744.422, 1364.77}
--------------------------------------------------------------------
### Vector-Matrix multiplication
### v = v ** S
myVector v = {2, 3, 5}
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = v ** S
Result: v = {110, 134, 164}
--------------------------------------------------------------------
### Vector-Matrix multiplication with matmul
### v = matmul(v, S)
myVector v = {2, 3, 5}
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = matmul(v, S)
Result: v = {110, 134, 164}
--------------------------------------------------------------------
### SymmMatrix-Vector multiplication
### v = O ** v
myVector v = {2, 3, 5}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating v = O ** v
Result: v = {35, 62, 86}
--------------------------------------------------------------------
### SymmMatrix-Matrix multiplication
### S = O ** S
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating S = O ** S
Result: S = 
{{79, 100, 130},
 {166, 222, 268},
 {262, 311, 379}}
--------------------------------------------------------------------
### Vector-SymmMatrix multiplication
### v = v ** O
myVector v = {2, 3, 5}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating v = v ** O
Result: v = {35, 62, 86}
--------------------------------------------------------------------
### Matrix-SymmMatrix multiplication
### M = M ** O
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating M = M ** O
Result: M = 
{{35, 62, 86},
 {110, 200, 245}}
--------------------------------------------------------------------
### DiagMatrix-Vector multiplication
### v = D ** v
myVector v = {2, 3, 5}
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating v = D ** v
Result: v = {4, 33, 115}
--------------------------------------------------------------------
### TridiagMatrix-Vector multiplication
### v = T ** v
myVector v = {2, 3, 5}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating v = T ** v
Result: v = {13, 112, 172}
--------------------------------------------------------------------
### TridiagMatrix-Matrix multiplication
### S = T ** S
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating S = T ** S
Result: S = 
{{25, 39, 49},
 {312, 389, 477},
 {524, 646, 776}}
--------------------------------------------------------------------
### LowerMatrix-Matrix multiplication
### S = L ** S
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating S = L ** S
Result: S = 
{{4, 6, 10},
 {91, 142, 178},
 {558, 697, 861}}
--------------------------------------------------------------------
### Vector-TridiagMatrix multiplication
### v = v ** T
myVector v = {2, 3, 5}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating v = v ** T
Result: v = {25, 134, 154}
--------------------------------------------------------------------
### Matrix-TridiagMatrix multiplication
### M = M ** T
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating M = M ** T
Result: M = 
{{25, 134, 154},
 {91, 389, 442}}
NO LINEAR ALGEBRA TESTS PERFORMED BECAUSE ACTIVE ARRAYS NOT YET SUPPORTED
====================================================================
   TESTING FILLING ARRAYS
--------------------------------------------------------------------
### Fill vector with "<<"
### (v << 0.1, 0.2)
myVector v = {2, 3, 5}
Evaluating (v << 0.1, 0.2)
Result: v = {0.1, 0.2, 5}
--------------------------------------------------------------------
### Overfill vector with "<<"
### (v << 0.1, 0.2, 0.3, 0.4)
myVector v = {2, 3, 5}
Evaluating (v << 0.1, 0.2, 0.3, 0.4)
*** Failed with: Row overflow in filling Vector with "<<" (in ../include/adept/Allocator.h:132)
*** Correct behaviour
--------------------------------------------------------------------
### Underfill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5)
Result: M = 
{{0.1, 0.2, 0.3},
 {0.4, 0.5, 13}}
--------------------------------------------------------------------
### Fill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6)
Result: M = 
{{0.1, 0.2, 0.3},
 {0.4, 0.5, 0.6}}
--------------------------------------------------------------------
### Overfill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
*** Failed with: Dimension overflow in filling array with "<<" (in ../include/adept/Allocator.h:154)
*** Correct behaviour
--------------------------------------------------------------------
### Fill vector with vectors using "<<"
### v << v(range(1,2)) << 0.1
myVector v = {2, 3, 5}
Evaluating v << v(range(1,2)) << 0.1
Result: v = {3, 5, 0.1}
--------------------------------------------------------------------
### Fill matrix with vector using "<<"
### M << 0.1 << 0.2 << 0.3 << v
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector v = {2, 3, 5}
Evaluating M << 0.1 << 0.2 << 0.3 << v
Result: M = 
{{0.1, 0.2, 0.3},
 {2, 3, 5}}
--------------------------------------------------------------------
### Fill matrix with vector using "<<"
### S << v << v << v
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myVector v = {2, 3, 5}
Evaluating S << v << v << v
Result: S = 
{{2, 3, 5},
 {2, 3, 5},
 {2, 3, 5}}
--------------------------------------------------------------------
### Assign array using range
### v = range(3,6)
myVector v = (empty rank-1 array)
Evaluating v = range(3,6)
Result: v = {3, 4, 5, 6}
====================================================================
   TESTING PRINTING WITH PLAIN STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
(empty rank-1 array)
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
2 3 5
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'
2 3 5
7 11 13
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'
2 3
5 7
11 13
17 19
23 29
31 37
====================================================================
   TESTING PRINTING WITH CSV STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
empty
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
2, 3, 5
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'
2, 3, 5
7, 11, 13
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'
2, 3
5, 7
11, 13
17, 19
23, 29
31, 37
====================================================================
   TESTING PRINTING WITH CURLY STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
(empty rank-1 array)
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
{2, 3, 5}
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'

{{2, 3, 5},
 {7, 11, 13}}
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'

{{{2, 3},
  {5, 7},
  {11, 13}},
 {{17, 19},
  {23, 29},
  {31, 37}}}
====================================================================
   TESTING PRINTING WITH MATLAB STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
[]
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
[2 3 5]
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'
[2 3 5;
 7 11 13]
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'
[2 3;
 5 7;
 11 13;
 17 19;
 23 29;
 31 37]
====================================================================
   TESTING EXPRESSION PRINTING
--------------------------------------------------------------------
### Send expression to standard output
### std::cout << M(0,__) + M(1,__) << '\n'
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating std::cout << M(0,__) + M(1,__) << '\n'
{9, 14, 18}
Result: M = 
{{2, 3, 5},
 {7, 11, 13}}
--------------------------------------------------------------------
### Send scalar expression to standard output
### std::cout << v(0) + v(1) << '\n'
myVector v = {2, 3, 5}
Evaluating std::cout << v(0) + v(1) << '\n'
5
Result: v = {2, 3, 5}
====================================================================
   TESTING BOUNDS CHECKING
--------------------------------------------------------------------
### Access vector out of bounds
### v(0) = v(4)
myVector v = {2, 3, 5}
Evaluating v(0) = v(4)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Access vector out of bounds
### v(0) = v(end-4)
myVector v = {2, 3, 5}
Evaluating v(0) = v(end-4)
*** Failed with: Array index (probably generated from a scalar expression containing "end") is out of bounds (in ../include/adept/RangeIndex.h:128)
*** Correct behaviour
--------------------------------------------------------------------
### Access matrix out of bounds
### M(0,0) = M(0,-1)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(0,0) = M(0,-1)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Access matrix out of bounds
### M(0,0) = M(end+1,1)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(0,0) = M(end+1,1)
*** Failed with: Array index (probably generated from a scalar expression containing "end") is out of bounds (in ../include/adept/RangeIndex.h:128)
*** Correct behaviour
====================================================================
Automatic Differentiation Stack (address 0x7ffeef756338):
   Currently attached - thread unsafe
   Recording status:
      Recording is ON
      3194 statements (1048576 allocated) and 3255 operations (1048576 allocated)
      151 gradients currently registered and a total of 206 needed (current index 151)
      Gradient list has no gaps
   Computation status:
      0 gradients assigned (0 allocated)
      Jacobian size: 0x0
      Independent indices:
      Dependent indices:  
      Parallel Jacobian calculation not available
====================================================================
In terms of run-time errors, all tests were passed

########################################################
### test_arrays_active_pausable
########################################################

Adept version 2.0.5:
  Compiled with g++ [4.2.1]
  Compiler flags "-g -O2"
  BLAS support from blas library
  Jacobians processed in blocks of size 4
Testing ACTIVE arrays
====================================================================
   TESTING ARRAY FUNCTIONALITY
--------------------------------------------------------------------
### Array "resize" member function
### M.resize(1,5)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M.resize(1,5)
Result: M = 
{{-3.10504e+231, -3.10504e+231, 5, 7, 11}}
--------------------------------------------------------------------
### Array "resize" with invalid dimensions
### M.resize(1)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M.resize(1)
*** Failed with: Invalid dimensions in array resize (in ../include/adept/Array.h:2015)
*** Correct behaviour
--------------------------------------------------------------------
### Array "resize" with "dimensions" function
### M.resize(dimensions(4,2))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M.resize(dimensions(4,2))
Result: M = 
{{-3.10504e+231, -3.10504e+231},
 {1.21791e-152, 4.82336e+228},
 {9.13608e+242, 9.2793e+199},
 {1.65197e-86, 8.47785e+175}}
--------------------------------------------------------------------
### Array "clear" member function
### M.clear()
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M.clear()
Result: M = (empty rank-2 array)
====================================================================
   TESTING BASIC EXPRESSIONS
--------------------------------------------------------------------
### Vector assignment to vector from empty
### v = w
myVector v = (empty rank-1 array)
myVector w = {7, 11, 13}
Evaluating v = w
Result: v = {7, 11, 13}
--------------------------------------------------------------------
### Vector assignment to expression from empty
### v = log(w) + 1.0
myVector v = (empty rank-1 array)
myVector w = {7, 11, 13}
Evaluating v = log(w) + 1.0
Result: v = {2.94591, 3.3979, 3.56495}
--------------------------------------------------------------------
### Matrix *= operator
### M *= 0.5
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M *= 0.5
Result: M = 
{{1, 1.5, 2.5},
 {3.5, 5.5, 6.5}}
--------------------------------------------------------------------
### Matrix = scalar
### M = x
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myReal x = -2
Evaluating M = x
Result: M = 
{{-2, -2, -2},
 {-2, -2, -2}}
--------------------------------------------------------------------
### Matrix = scalar expression
### M = (10.0*x)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myReal x = -2
Evaluating M = (10.0*x)
Result: M = 
{{-20, -20, -20},
 {-20, -20, -20}}
====================================================================
   TESTING BASIC FUNCTIONS
--------------------------------------------------------------------
### max
### v = max(v,w/3.0)
myVector v = {2, 3, 5}
myVector w = {7, 11, 13}
Evaluating v = max(v,w/3.0)
Result: v = {2.33333, 3.66667, 5}
--------------------------------------------------------------------
### min
### v = min(v,w/3.0)
myVector v = {2, 3, 5}
myVector w = {7, 11, 13}
Evaluating v = min(v,w/3.0)
Result: v = {2, 3, 4.33333}
====================================================================
   TESTING ARRAY SLICING
--------------------------------------------------------------------
### Array indexing rvalue
### x = M(1,end-1)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = M(1,end-1)
Result: x = 11
--------------------------------------------------------------------
### Array indexing rvalue out of range (SHOULD FAIL)
### x = M(1,3)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = M(1,3)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Array indexing lvalue
### M(1,end-1) *= -1.0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(1,end-1) *= -1.0
Result: M = 
{{2, 3, 5},
 {7, -11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue
### v = M(__,end)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = M(__,end)
Result: v = {5, 13}
--------------------------------------------------------------------
### contiguous subarray lvalue
### M(end-1,__) /= 2.0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(end-1,__) /= 2.0
Result: M = 
{{1, 1.5, 2.5},
 {7, 11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue and lvalue
### M(__,1) = N(__,2)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M(__,1) = N(__,2)
Result: M = 
{{2, 23, 5},
 {7, 37, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue using range
### v = 2.0 * M(1,range(1,2))
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = 2.0 * M(1,range(1,2))
Result: v = {22, 26}
--------------------------------------------------------------------
### contiguous subarray lvalue using range
### M(end-1,range(0,1)) = log(v(range(1,2)))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector v = {2, 3, 5}
Evaluating M(end-1,range(0,1)) = log(v(range(1,2)))
Result: M = 
{{1.09861, 1.60944, 5},
 {7, 11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue using subset
### M = 2.0 * N.subset(1,1,1,2)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = 2.0 * N.subset(1,1,1,2)
Result: M = 
{{62, 74}}
--------------------------------------------------------------------
### contiguous subarray lvalue using subset
### v.subset(end-1,end) *= 10.0
myVector v = {2, 3, 5}
Evaluating v.subset(end-1,end) *= 10.0
Result: v = {2, 30, 50}
--------------------------------------------------------------------
### regular subarray rvalue
### v = w(stride(end,0,-1))
myVector v = (empty rank-1 array)
myVector w = {7, 11, 13}
Evaluating v = w(stride(end,0,-1))
Result: v = {13, 11, 7}
--------------------------------------------------------------------
### regular subarray lvalue
### M(0,stride(0,end,2)) *= w(stride(end,0,-2))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector w = {7, 11, 13}
Evaluating M(0,stride(0,end,2)) *= w(stride(end,0,-2))
Result: M = 
{{26, 3, 35},
 {7, 11, 13}}
--------------------------------------------------------------------
### irregular subarray rvalue
### M = N(stride(1,0,-1),find(N(0,__)>18))
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = N(stride(1,0,-1),find(N(0,__)>18))
Result: M = 
{{31, 37},
 {19, 23}}
--------------------------------------------------------------------
### irregular subarray lvalue
### M(stride(1,0,-1),find(M(0,__)>4)) = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(stride(1,0,-1),find(M(0,__)>4)) = 0
Result: M = 
{{2, 3, 0},
 {7, 11, 0}}
--------------------------------------------------------------------
### slice leading dimension
### M[end] = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M[end] = 0
Result: M = 
{{2, 3, 5},
 {0, 0, 0}}
--------------------------------------------------------------------
### slice two dimensions
### M[end][0] = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M[end][0] = 0
Result: M = 
{{2, 3, 5},
 {0, 11, 13}}
--------------------------------------------------------------------
### diag_vector member function as rvalue
### v = diag_vector(S,1)
myVector v = (empty rank-1 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = diag_vector(S,1)
Result: v = {3, 13}
--------------------------------------------------------------------
### diag_vector member function as lvalue
### S.diag_vector() += v
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myVector v = {2, 3, 5}
Evaluating S.diag_vector() += v
Result: S = 
{{4, 3, 5},
 {7, 14, 13},
 {17, 19, 28}}
--------------------------------------------------------------------
### diag_matrix member function
### S = v.diag_matrix()
myMatrix S = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating S = v.diag_matrix()
Result: S = 
{{2, 0, 0},
 {0, 3, 0},
 {0, 0, 5}}
--------------------------------------------------------------------
### diag_matrix external function
### S = diag_matrix(v)
myMatrix S = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating S = diag_matrix(v)
Result: S = 
{{2, 0, 0},
 {0, 3, 0},
 {0, 0, 5}}
--------------------------------------------------------------------
### transpose as rvalue via T member function
### N = 2.0 * M.T()
myMatrix N = (empty rank-2 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating N = 2.0 * M.T()
Result: N = 
{{4, 14},
 {6, 22},
 {10, 26}}
--------------------------------------------------------------------
### transpose as rvalue via permute member function
### N = 2.0 * M.permute(1,0)
myMatrix N = (empty rank-2 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating N = 2.0 * M.permute(1,0)
Result: N = 
{{4, 14},
 {6, 22},
 {10, 26}}
--------------------------------------------------------------------
### matrix indexing (scalar,non-contiguous)
### v = N(1,index)
myVector v = (empty rank-1 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating v = N(1,index)
Result: v = {31, 29}
--------------------------------------------------------------------
### matrix indexing (non-contiguous,scalar)
### v = N(index,1)
myVector v = (empty rank-1 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating v = N(index,1)
Result: v = {31, 19}
--------------------------------------------------------------------
### 2D arbitrary index as rvalue
### M = const_cast<const myMatrix&>(N)(index,index)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating M = const_cast<const myMatrix&>(N)(index,index)
Result: M = 
{{31, 29},
 {19, 17}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue assigned to scalar expression
### M(index,index) = 2.0*(myReal)(4.0)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating M(index,index) = 2.0*(myReal)(4.0)
Result: M = 
{{8, 8, 5},
 {8, 8, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue
### M(index,index) = N(__,range(1,2))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating M(index,index) = N(__,range(1,2))
Result: M = 
{{37, 31, 5},
 {23, 19, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with assign-multiply operator
### M(index,index) *= 10.0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
intVector index = {1, 0}
Evaluating M(index,index) *= 10.0
Result: M = 
{{20, 30, 5},
 {70, 110, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with aliased right-hand-side
### M(index,index) = M(__,range(0,1))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
intVector index = {1, 0}
Evaluating M(index,index) = M(__,range(0,1))
Result: M = 
{{11, 7, 5},
 {3, 2, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with aliased right-hand-side and eval function
### M(index,index) = eval(M(__,range(0,1)))
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
intVector index = {1, 0}
Evaluating M(index,index) = eval(M(__,range(0,1)))
Result: M = 
{{11, 7, 5},
 {3, 2, 13}}
--------------------------------------------------------------------
### reshape member function
### M >>= vlong.reshape(3,4)
myMatrix M = (empty rank-2 array)
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating M >>= vlong.reshape(3,4)
Result: M = 
{{1, 2, 3, 4},
 {5, 6, 7, 8},
 {9, 10, 11, 12}}
--------------------------------------------------------------------
### reshape member function with invalid dimensions
### M >>= vlong.reshape(5,5)
myMatrix M = (empty rank-2 array)
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating M >>= vlong.reshape(5,5)
*** Failed with: Size of reshaped array does not match original vector
*** Correct behaviour
--------------------------------------------------------------------
### end/2 indexing
### vlong(range(end/2,end)) = 0.0
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating vlong(range(end/2,end)) = 0.0
Result: vlong = {1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0}
--------------------------------------------------------------------
### end/2 indexing
### vlong(range(0,end/2)) = 0.0
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating vlong(range(0,end/2)) = 0.0
Result: vlong = {0, 0, 0, 0, 0, 0, 7, 8, 9, 10, 11, 12}
--------------------------------------------------------------------
### end/2 indexing
### vlong.subset(end/2,end) = 0.0
myVector vlong = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
Evaluating vlong.subset(end/2,end) = 0.0
Result: vlong = {1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0}
====================================================================
   TESTING REDUCTION OPERATIONS
--------------------------------------------------------------------
### full sum
### x = sum(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = sum(M)
Result: x = 41
--------------------------------------------------------------------
### full product
### x = product(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = product(M)
Result: x = 30030
--------------------------------------------------------------------
### full maxval
### x = maxval(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = maxval(M)
Result: x = 13
--------------------------------------------------------------------
### full minval
### x = minval(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = minval(M)
Result: x = 2
--------------------------------------------------------------------
### full norm2
### x = norm2(M)
myReal x = -2
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = norm2(M)
Result: x = 19.4165
--------------------------------------------------------------------
### 1-dimension mean
### v = 0.5 * mean(M,0)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = 0.5 * mean(M,0)
Result: v = {2.25, 3.5, 4.5}
--------------------------------------------------------------------
### 1-dimension norm2
### v = norm2(M,1)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = norm2(M,1)
Result: v = {6.16441, 18.412}
--------------------------------------------------------------------
### dot product
### x = dot_product(w,w(stride(end,0,-1)))
myReal x = -2
myVector w = {7, 11, 13}
Evaluating x = dot_product(w,w(stride(end,0,-1)))
Result: x = 303
--------------------------------------------------------------------
### dot product on expressions
### x = dot_product(2.0*w,w(stride(end,0,-1))+1.0)
myReal x = -2
myVector w = {7, 11, 13}
Evaluating x = dot_product(2.0*w,w(stride(end,0,-1))+1.0)
Result: x = 668
--------------------------------------------------------------------
### 1-dimension maxval
### v = maxval(M,1)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = maxval(M,1)
Result: v = {5, 13}
--------------------------------------------------------------------
### 1-dimension minval
### v = minval(M,1)
myVector v = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = minval(M,1)
Result: v = {2, 7}
--------------------------------------------------------------------
### 1D interpolation
### v = interp(value(v), w, Vector(value(w)/3.0))
myVector v = {2, 3, 5}
myVector w = {7, 11, 13}
Evaluating v = interp(value(v), w, Vector(value(w)/3.0))
Result: v = {8.33333, 11.6667, 12.3333}
--------------------------------------------------------------------
### 1D interpolation
### v = interp(value(v), w, value(w)/3.0)
myVector v = {2, 3, 5}
myVector w = {7, 11, 13}
Evaluating v = interp(value(v), w, value(w)/3.0)
Result: v = {8.33333, 11.6667, 12.3333}
--------------------------------------------------------------------
### all reduction
### b = all(M > 8.0)
bool b = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating b = all(M > 8.0)
Result: b = 0
--------------------------------------------------------------------
### any reduction
### b = any(M > 8.0)
bool b = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating b = any(M > 8.0)
Result: b = 1
--------------------------------------------------------------------
### count reduction
### c = count(M > 8.0)
int c = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating c = count(M > 8.0)
Result: c = 2
--------------------------------------------------------------------
### 1-dimension all reduction
### B = all(M > 8.0, 1)
boolVector B = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating B = all(M > 8.0, 1)
Result: B = {0, 0}
--------------------------------------------------------------------
### 1-dimension any reduction
### B = any(M > 8.0, 1)
boolVector B = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating B = any(M > 8.0, 1)
Result: B = {0, 1}
--------------------------------------------------------------------
### 1-dimension count reduction
### index = count(M > 8.0, 1)
intVector index = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating index = count(M > 8.0, 1)
Result: index = {0, 2}
====================================================================
   TESTING CONDITIONAL OPERATIONS
--------------------------------------------------------------------
### where construct, scalar right-hand-side
### M.where(N > 20) = 0
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = 0
Result: M = 
{{2, 3, 0},
 {0, 0, 0}}
--------------------------------------------------------------------
### where construct, expression right-hand-side
### M.where(N > 20) = -N
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = -N
Result: M = 
{{2, 3, -23},
 {-29, -31, -37}}
--------------------------------------------------------------------
### where construct, scalar either-or right-hand-side
### M.where(N > 20) = either_or(0,1)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = either_or(0,1)
Result: M = 
{{1, 1, 0},
 {0, 0, 0}}
--------------------------------------------------------------------
### where construct, expression either-or right-hand-side
### M.where(N > 20) = either_or(-N,N)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = either_or(-N,N)
Result: M = 
{{17, 19, -23},
 {-29, -31, -37}}
--------------------------------------------------------------------
### find construct, scalar right-hand-side
### v(find(v > 3.5)) = 0
myVector v = {2, 3, 5}
Evaluating v(find(v > 3.5)) = 0
Result: v = {2, 3, 0}
--------------------------------------------------------------------
### find construct, expression right-hand-side
### v(find(v > 3.5)) = -v(range(end,end))
myVector v = {2, 3, 5}
Evaluating v(find(v > 3.5)) = -v(range(end,end))
Result: v = {2, 3, -5}
--------------------------------------------------------------------
### find construct, multiply-assign right-hand-side
### v(find(v != 5.0)) *= 10.0
myVector v = {2, 3, 5}
Evaluating v(find(v != 5.0)) *= 10.0
Result: v = {20, 30, 5}
====================================================================
   TESTING SPECIAL SQUARE MATRICES
--------------------------------------------------------------------
### SymmMatrix "resize" member function
### O.resize(5)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.resize(5)
Result: O = 
{{0, 0, 0, 0, 0},
 {0, 0, 0, 0, 0},
 {0, 0, 0, 0, 0},
 {0, 0, 0, 0, 0},
 {0, 0, 0, 0, 0}}
--------------------------------------------------------------------
### SymmMatrix "resize" with invalid dimensions
### O.resize(4,5)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.resize(4,5)
*** Failed with: Square matrix must have the same x and y dimensions (in ../include/adept/SpecialMatrix.h:1527)
*** Correct behaviour
--------------------------------------------------------------------
### SymmMatrix "clear" member function
### O.clear()
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.clear()
Result: O = (empty rank-2 array)
--------------------------------------------------------------------
### SymmMatrix assign from dense matrix
### O = S
mySymmMatrix O = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating O = S
Result: O = 
{{2, 7, 17},
 {7, 11, 19},
 {17, 19, 23}}
--------------------------------------------------------------------
### DiagMatrix assign from dense matrix
### D = S
myDiagMatrix D = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating D = S
Result: D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### TridiagMatrix assign from dense matrix
### T = S
myTridiagMatrix T = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating T = S
Result: T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
--------------------------------------------------------------------
### LowerMatrix assign from dense matrix
### L = S
myLowerMatrix L = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating L = S
Result: L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
--------------------------------------------------------------------
### UpperMatrix assign from dense matrix
### U = S
myUpperMatrix U = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating U = S
Result: U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
--------------------------------------------------------------------
### SymmMatrix += operator
### O += 3.0
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O += 3.0
Result: O = 
{{10, 5, 6},
 {5, 14, 8},
 {6, 8, 16}}
--------------------------------------------------------------------
### DiagMatrix += operator
### D += 3.0
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating D += 3.0
Result: D = 
{{5, 0, 0},
 {0, 14, 0},
 {0, 0, 26}}
--------------------------------------------------------------------
### TridiagMatrix += operator
### T += 3.0
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating T += 3.0
Result: T = 
{{5, 6, 0},
 {10, 14, 16},
 {0, 22, 26}}
--------------------------------------------------------------------
### LowerMatrix += operator
### L += 3.0
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating L += 3.0
Result: L = 
{{5, 0, 0},
 {10, 14, 0},
 {20, 22, 26}}
--------------------------------------------------------------------
### UpperMatrix += operator
### U += 3.0
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating U += 3.0
Result: U = 
{{5, 6, 8},
 {0, 14, 16},
 {0, 0, 26}}
--------------------------------------------------------------------
### SymmMatrix as rvalue
### M = O
myMatrix M = (empty rank-2 array)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating M = O
Result: M = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
--------------------------------------------------------------------
### DiagMatrix as rvalue
### M = D
myMatrix M = (empty rank-2 array)
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating M = D
Result: M = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### TridiagMatrix as rvalue
### M = T
myMatrix M = (empty rank-2 array)
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating M = T
Result: M = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
--------------------------------------------------------------------
### LowerMatrix as rvalue
### M = L
myMatrix M = (empty rank-2 array)
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating M = L
Result: M = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
--------------------------------------------------------------------
### UpperMatrix as rvalue
### M = U
myMatrix M = (empty rank-2 array)
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating M = U
Result: M = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
--------------------------------------------------------------------
### SymmMatrix assign from scalar expression
### O = 2.0*(myReal)(4.0)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O = 2.0*(myReal)(4.0)
Result: O = 
{{8, 8, 8},
 {8, 8, 8},
 {8, 8, 8}}
--------------------------------------------------------------------
### UpperMatrix assign from scalar expression
### U = 2.0*(myReal)(4.0)
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating U = 2.0*(myReal)(4.0)
Result: U = 
{{8, 8, 8},
 {0, 8, 8},
 {0, 0, 8}}
--------------------------------------------------------------------
### SymmMatrix diag_vector member function as lvalue (upper)
### O.diag_vector(1) = 0
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.diag_vector(1) = 0
Result: O = 
{{7, 0, 3},
 {0, 11, 0},
 {3, 0, 13}}
--------------------------------------------------------------------
### SymmMatrix diag_vector member function as lvalue (lower)
### O.diag_vector(-2) += 10.0
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating O.diag_vector(-2) += 10.0
Result: O = 
{{7, 2, 13},
 {2, 11, 5},
 {13, 5, 13}}
--------------------------------------------------------------------
### DiagMatrix diag_vector member function as lvalue
### D.diag_vector() = 0.0
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating D.diag_vector() = 0.0
Result: D = 
{{0, 0, 0},
 {0, 0, 0},
 {0, 0, 0}}
--------------------------------------------------------------------
### DiagMatrix diag_vector member function incorrectly using offdiagonal
### D.diag_vector(1) = 0.0
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating D.diag_vector(1) = 0.0
*** Failed with: Attempt to get lvalue diagonal to off-diagonal in BandMatrix (in ../include/adept/SpecialMatrix.h:350)
*** Correct behaviour
--------------------------------------------------------------------
### TridiagMatrix diag_vector member function as lvalue (upper)
### T.diag_vector(1) += 10.0
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating T.diag_vector(1) += 10.0
Result: T = 
{{2, 13, 0},
 {7, 11, 23},
 {0, 19, 23}}
--------------------------------------------------------------------
### TridiagMatrix diag_vector member function as lvalue (lower)
### T.diag_vector(-1) = 0.0
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating T.diag_vector(-1) = 0.0
Result: T = 
{{2, 3, 0},
 {0, 11, 13},
 {0, 0, 23}}
--------------------------------------------------------------------
### LowerMatrix diag_vector member function as lvalue (lower)
### L.diag_vector(-1) = 0.0
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating L.diag_vector(-1) = 0.0
Result: L = 
{{2, 0, 0},
 {0, 11, 0},
 {17, 0, 23}}
--------------------------------------------------------------------
### LowerMatrix diag_vector member function as lvalue (upper)
### L.diag_vector(1) = 0.0
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating L.diag_vector(1) = 0.0
*** Failed with: Attempt to get lvalue to an upper diagonal of a lower-triangular matrix (in ../include/adept/SpecialMatrix.h:683)
*** Correct behaviour
--------------------------------------------------------------------
### UpperMatrix diag_vector member function as lvalue (lower)
### U.diag_vector(-1) = 0.0
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating U.diag_vector(-1) = 0.0
*** Failed with: Attempt to get lvalue to a lower diagonal of an upper-triangular matrix (in ../include/adept/SpecialMatrix.h:810)
*** Correct behaviour
--------------------------------------------------------------------
### UpperMatrix diag_vector member function as lvalue (upper)
### U.diag_vector(1) = 0.0
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating U.diag_vector(1) = 0.0
Result: U = 
{{2, 0, 5},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(1) = -1.0
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.diag_vector(1) = -1.0
Result: Q = 
{{3, -1, 0, 0, 0},
 {2, 3, -1, 0, 0},
 {1, 2, 3, -1, 0},
 {0, 1, 2, 3, -1},
 {0, 0, 1, 2, 3}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(0) = -1.0
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.diag_vector(0) = -1.0
Result: Q = 
{{-1, 4, 0, 0, 0},
 {2, -1, 4, 0, 0},
 {1, 2, -1, 4, 0},
 {0, 1, 2, -1, 4},
 {0, 0, 1, 2, -1}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(-1) = -1.0
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.diag_vector(-1) = -1.0
Result: Q = 
{{3, 4, 0, 0, 0},
 {-1, 3, 4, 0, 0},
 {1, -1, 3, 4, 0},
 {0, 1, -1, 3, 4},
 {0, 0, 1, -1, 3}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(-2) = -1.0
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.diag_vector(-2) = -1.0
Result: Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {-1, 2, 3, 4, 0},
 {0, -1, 2, 3, 4},
 {0, 0, -1, 2, 3}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function
### M = S.submatrix_on_diagonal(1,2)
myMatrix M = (empty rank-2 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating M = S.submatrix_on_diagonal(1,2)
Result: M = 
{{11, 13},
 {19, 23}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function as lvalue
### S.submatrix_on_diagonal(0,1) = 0.0
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating S.submatrix_on_diagonal(0,1) = 0.0
Result: S = 
{{0, 0, 5},
 {0, 0, 13},
 {17, 19, 23}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function to non-square matrix
### M = N.submatrix_on_diagonal(1,2)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = N.submatrix_on_diagonal(1,2)
*** Failed with: submatrix_on_diagonal member function only applicable to square matrices (in ../include/adept/Array.h:1586)
*** Correct behaviour
--------------------------------------------------------------------
### SymmMatrix submatrix_on_diagonal member function
### P = O.submatrix_on_diagonal(1,2)
mySymmMatrix P = (empty rank-2 array)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating P = O.submatrix_on_diagonal(1,2)
Result: P = 
{{11, 5},
 {5, 13}}
--------------------------------------------------------------------
### DiagMatrix submatrix_on_diagonal member function
### E = D.submatrix_on_diagonal(1,2)
myDiagMatrix E = (empty rank-2 array)
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating E = D.submatrix_on_diagonal(1,2)
Result: E = 
{{11, 0},
 {0, 23}}
--------------------------------------------------------------------
### TridiagMatrix submatrix_on_diagonal member function
### TT = T.submatrix_on_diagonal(1,2)
myTridiagMatrix TT = (empty rank-2 array)
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating TT = T.submatrix_on_diagonal(1,2)
Result: TT = 
{{11, 13},
 {19, 23}}
--------------------------------------------------------------------
### LowerMatrix submatrix_on_diagonal member function
### LL = L.submatrix_on_diagonal(1,2)
myLowerMatrix LL = (empty rank-2 array)
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating LL = L.submatrix_on_diagonal(1,2)
Result: LL = 
{{11, 0},
 {19, 23}}
--------------------------------------------------------------------
### UpperMatrix submatrix_on_diagonal member function
### UU = U.submatrix_on_diagonal(1,2)
myUpperMatrix UU = (empty rank-2 array)
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating UU = U.submatrix_on_diagonal(1,2)
Result: UU = 
{{11, 13},
 {0, 23}}
--------------------------------------------------------------------
### Odd band matrix submatrix_on_diagonal member function
### R = Q.submatrix_on_diagonal(1,3)
myOddBandMatrix R = (empty rank-2 array)
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating R = Q.submatrix_on_diagonal(1,3)
Result: R = 
{{3, 4, 0},
 {2, 3, 4},
 {1, 2, 3}}
--------------------------------------------------------------------
### Odd band matrix submatrix_on_diagonal as lvalue
### Q.submatrix_on_diagonal(1,3) = -1
myOddBandMatrix Q = 
{{3, 4, 0, 0, 0},
 {2, 3, 4, 0, 0},
 {1, 2, 3, 4, 0},
 {0, 1, 2, 3, 4},
 {0, 0, 1, 2, 3}}
Evaluating Q.submatrix_on_diagonal(1,3) = -1
Result: Q = 
{{3, 4, 0, 0, 0},
 {2, -1, -1, 0, 0},
 {1, -1, -1, -1, 0},
 {0, -1, -1, -1, 4},
 {0, 0, 1, 2, 3}}
--------------------------------------------------------------------
### SymmMatrix transpose as rvalue via T member function
### P = O.T()
mySymmMatrix P = (empty rank-2 array)
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating P = O.T()
Result: P = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
--------------------------------------------------------------------
### DiagMatrix transpose as rvalue via T member function
### E = D.T()
myDiagMatrix E = (empty rank-2 array)
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating E = D.T()
Result: E = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### TridiagMatrix transpose as rvalue via T member function
### TT = T.T()
myTridiagMatrix TT = (empty rank-2 array)
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating TT = T.T()
Result: TT = 
{{2, 7, 0},
 {3, 11, 19},
 {0, 13, 23}}
--------------------------------------------------------------------
### LowerMatrix transpose as rvalue via T member function
### U = L.T()
myUpperMatrix U = (empty rank-2 array)
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating U = L.T()
Result: U = 
{{2, 7, 17},
 {0, 11, 19},
 {0, 0, 23}}
--------------------------------------------------------------------
### UpperMatrix transpose as rvalue via T member function
### L = U.T()
myLowerMatrix L = (empty rank-2 array)
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating L = U.T()
Result: L = 
{{2, 0, 0},
 {3, 11, 0},
 {5, 13, 23}}
====================================================================
   TESTING EXPANSION OPERATIONS
--------------------------------------------------------------------
### Outer product
### M = outer_product(v,v)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = outer_product(v,v)
Result: M = 
{{4, 6, 10},
 {6, 9, 15},
 {10, 15, 25}}
--------------------------------------------------------------------
### Outer product on indexed array
### M = outer_product(v,v(stride(end,0,-1)))
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = outer_product(v,v(stride(end,0,-1)))
Result: M = 
{{10, 6, 4},
 {15, 9, 6},
 {25, 15, 10}}
--------------------------------------------------------------------
### Outer product on expressions
### M = outer_product(2.0*v,v-1.0)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = outer_product(2.0*v,v-1.0)
Result: M = 
{{4, 8, 16},
 {6, 12, 24},
 {10, 20, 40}}
--------------------------------------------------------------------
### Vector spread of dimension 0
### M = spread<0>(v,2)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = spread<0>(v,2)
Result: M = 
{{2, 3, 5},
 {2, 3, 5}}
--------------------------------------------------------------------
### Vector spread of dimension 1
### M = spread<1>(v,2)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = spread<1>(v,2)
Result: M = 
{{2, 2},
 {3, 3},
 {5, 5}}
--------------------------------------------------------------------
### Vector spread with expression argument
### M = spread<1>(v*2.0,2)
myMatrix M = (empty rank-2 array)
myVector v = {2, 3, 5}
Evaluating M = spread<1>(v*2.0,2)
Result: M = 
{{4, 4},
 {6, 6},
 {10, 10}}
--------------------------------------------------------------------
### Matrix spread of dimension 0
### A = spread<0>(M,2)
myArray3D A = (empty rank-3 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating A = spread<0>(M,2)
Result: A = 
{{{2, 3, 5},
  {7, 11, 13}},
 {{2, 3, 5},
  {7, 11, 13}}}
--------------------------------------------------------------------
### Matrix spread of dimension 1
### A = spread<1>(M,2)
myArray3D A = (empty rank-3 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating A = spread<1>(M,2)
Result: A = 
{{{2, 3, 5},
  {2, 3, 5}},
 {{7, 11, 13},
  {7, 11, 13}}}
--------------------------------------------------------------------
### Matrix spread of dimension 2
### A = spread<2>(M,2)
myArray3D A = (empty rank-3 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating A = spread<2>(M,2)
Result: A = 
{{{2, 2},
  {3, 3},
  {5, 5}},
 {{7, 7},
  {11, 11},
  {13, 13}}}
====================================================================
   TESTING MATRIX MULTIPLICATION
--------------------------------------------------------------------
### Matrix-Vector multiplication
### w = M ** v
myVector w = (empty rank-1 array)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector v = {2, 3, 5}
Evaluating w = M ** v
Result: w = {38, 112}
--------------------------------------------------------------------
### Matrix-Vector multiplication with strided matrix
### w = Mstrided ** v
myVector w = (empty rank-1 array)
myMatrix Mstrided = 
{{2, 3, 5},
 {7, 11, 13}}
myVector v = {2, 3, 5}
Evaluating w = Mstrided ** v
Result: w = {38, 112}
--------------------------------------------------------------------
### Matrix-Matrix multiplication
### M = N.T() ** N
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = N.T() ** N
Result: M = 
{{1130, 1222, 1464},
 {1222, 1322, 1584},
 {1464, 1584, 1898}}
--------------------------------------------------------------------
### Matrix-Matrix multiplication with matmul
### M = matmul(N.T(), N)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = matmul(N.T(), N)
Result: M = 
{{1130, 1222, 1464},
 {1222, 1322, 1584},
 {1464, 1584, 1898}}
--------------------------------------------------------------------
### Matrix-Matrix multiplication with inner dimension mismatch
### M = N ** N
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M = N ** N
*** Failed with: Inner dimension mismatch in array multiplication (in ../include/adept/matmul.h:36)
*** Correct behaviour
--------------------------------------------------------------------
### Matrix-Matrix-Vector multiplication
### v = S ** S ** v
myVector v = {2, 3, 5}
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = S ** S ** v
Result: v = {1442, 4176, 7512}
--------------------------------------------------------------------
### Matrix-Matrix-Vector multiplication
### v = S ** log(S) ** S(0,__)
myVector v = (empty rank-1 array)
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = S ** log(S) ** S(0,__)
Result: v = {248.075, 744.422, 1364.77}
--------------------------------------------------------------------
### Vector-Matrix multiplication
### v = v ** S
myVector v = {2, 3, 5}
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = v ** S
Result: v = {110, 134, 164}
--------------------------------------------------------------------
### Vector-Matrix multiplication with matmul
### v = matmul(v, S)
myVector v = {2, 3, 5}
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = matmul(v, S)
Result: v = {110, 134, 164}
--------------------------------------------------------------------
### SymmMatrix-Vector multiplication
### v = O ** v
myVector v = {2, 3, 5}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating v = O ** v
Result: v = {35, 62, 86}
--------------------------------------------------------------------
### SymmMatrix-Matrix multiplication
### S = O ** S
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating S = O ** S
Result: S = 
{{79, 100, 130},
 {166, 222, 268},
 {262, 311, 379}}
--------------------------------------------------------------------
### Vector-SymmMatrix multiplication
### v = v ** O
myVector v = {2, 3, 5}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating v = v ** O
Result: v = {35, 62, 86}
--------------------------------------------------------------------
### Matrix-SymmMatrix multiplication
### M = M ** O
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating M = M ** O
Result: M = 
{{35, 62, 86},
 {110, 200, 245}}
--------------------------------------------------------------------
### DiagMatrix-Vector multiplication
### v = D ** v
myVector v = {2, 3, 5}
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating v = D ** v
Result: v = {4, 33, 115}
--------------------------------------------------------------------
### TridiagMatrix-Vector multiplication
### v = T ** v
myVector v = {2, 3, 5}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating v = T ** v
Result: v = {13, 112, 172}
--------------------------------------------------------------------
### TridiagMatrix-Matrix multiplication
### S = T ** S
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating S = T ** S
Result: S = 
{{25, 39, 49},
 {312, 389, 477},
 {524, 646, 776}}
--------------------------------------------------------------------
### LowerMatrix-Matrix multiplication
### S = L ** S
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating S = L ** S
Result: S = 
{{4, 6, 10},
 {91, 142, 178},
 {558, 697, 861}}
--------------------------------------------------------------------
### Vector-TridiagMatrix multiplication
### v = v ** T
myVector v = {2, 3, 5}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating v = v ** T
Result: v = {25, 134, 154}
--------------------------------------------------------------------
### Matrix-TridiagMatrix multiplication
### M = M ** T
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating M = M ** T
Result: M = 
{{25, 134, 154},
 {91, 389, 442}}
NO LINEAR ALGEBRA TESTS PERFORMED BECAUSE ACTIVE ARRAYS NOT YET SUPPORTED
====================================================================
   TESTING FILLING ARRAYS
--------------------------------------------------------------------
### Fill vector with "<<"
### (v << 0.1, 0.2)
myVector v = {2, 3, 5}
Evaluating (v << 0.1, 0.2)
Result: v = {0.1, 0.2, 5}
--------------------------------------------------------------------
### Overfill vector with "<<"
### (v << 0.1, 0.2, 0.3, 0.4)
myVector v = {2, 3, 5}
Evaluating (v << 0.1, 0.2, 0.3, 0.4)
*** Failed with: Row overflow in filling Vector with "<<" (in ../include/adept/Allocator.h:132)
*** Correct behaviour
--------------------------------------------------------------------
### Underfill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5)
Result: M = 
{{0.1, 0.2, 0.3},
 {0.4, 0.5, 13}}
--------------------------------------------------------------------
### Fill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6)
Result: M = 
{{0.1, 0.2, 0.3},
 {0.4, 0.5, 0.6}}
--------------------------------------------------------------------
### Overfill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
*** Failed with: Dimension overflow in filling array with "<<" (in ../include/adept/Allocator.h:154)
*** Correct behaviour
--------------------------------------------------------------------
### Fill vector with vectors using "<<"
### v << v(range(1,2)) << 0.1
myVector v = {2, 3, 5}
Evaluating v << v(range(1,2)) << 0.1
Result: v = {3, 5, 0.1}
--------------------------------------------------------------------
### Fill matrix with vector using "<<"
### M << 0.1 << 0.2 << 0.3 << v
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector v = {2, 3, 5}
Evaluating M << 0.1 << 0.2 << 0.3 << v
Result: M = 
{{0.1, 0.2, 0.3},
 {2, 3, 5}}
--------------------------------------------------------------------
### Fill matrix with vector using "<<"
### S << v << v << v
myMatrix S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myVector v = {2, 3, 5}
Evaluating S << v << v << v
Result: S = 
{{2, 3, 5},
 {2, 3, 5},
 {2, 3, 5}}
--------------------------------------------------------------------
### Assign array using range
### v = range(3,6)
myVector v = (empty rank-1 array)
Evaluating v = range(3,6)
Result: v = {3, 4, 5, 6}
====================================================================
   TESTING PRINTING WITH PLAIN STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
(empty rank-1 array)
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
2 3 5
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'
2 3 5
7 11 13
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'
2 3
5 7
11 13
17 19
23 29
31 37
====================================================================
   TESTING PRINTING WITH CSV STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
empty
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
2, 3, 5
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'
2, 3, 5
7, 11, 13
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'
2, 3
5, 7
11, 13
17, 19
23, 29
31, 37
====================================================================
   TESTING PRINTING WITH CURLY STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
(empty rank-1 array)
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
{2, 3, 5}
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'

{{2, 3, 5},
 {7, 11, 13}}
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'

{{{2, 3},
  {5, 7},
  {11, 13}},
 {{17, 19},
  {23, 29},
  {31, 37}}}
====================================================================
   TESTING PRINTING WITH MATLAB STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
[]
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
[2 3 5]
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'
[2 3 5;
 7 11 13]
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'
[2 3;
 5 7;
 11 13;
 17 19;
 23 29;
 31 37]
====================================================================
   TESTING EXPRESSION PRINTING
--------------------------------------------------------------------
### Send expression to standard output
### std::cout << M(0,__) + M(1,__) << '\n'
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating std::cout << M(0,__) + M(1,__) << '\n'
{9, 14, 18}
Result: M = 
{{2, 3, 5},
 {7, 11, 13}}
--------------------------------------------------------------------
### Send scalar expression to standard output
### std::cout << v(0) + v(1) << '\n'
myVector v = {2, 3, 5}
Evaluating std::cout << v(0) + v(1) << '\n'
5
Result: v = {2, 3, 5}
====================================================================
   TESTING BOUNDS CHECKING
--------------------------------------------------------------------
### Access vector out of bounds
### v(0) = v(4)
myVector v = {2, 3, 5}
Evaluating v(0) = v(4)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Access vector out of bounds
### v(0) = v(end-4)
myVector v = {2, 3, 5}
Evaluating v(0) = v(end-4)
*** Failed with: Array index (probably generated from a scalar expression containing "end") is out of bounds (in ../include/adept/RangeIndex.h:128)
*** Correct behaviour
--------------------------------------------------------------------
### Access matrix out of bounds
### M(0,0) = M(0,-1)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(0,0) = M(0,-1)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Access matrix out of bounds
### M(0,0) = M(end+1,1)
myMatrix M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(0,0) = M(end+1,1)
*** Failed with: Array index (probably generated from a scalar expression containing "end") is out of bounds (in ../include/adept/RangeIndex.h:128)
*** Correct behaviour
====================================================================
Automatic Differentiation Stack (address 0x7ffeed3cb1b8):
   Currently attached - thread unsafe
   Recording status:
      Recording is PAUSED
      0 statements (1048576 allocated) and 0 operations (1048576 allocated)
      0 gradients currently registered and a total of 1 needed (current index 0)
      Gradient list has no gaps
   Computation status:
      0 gradients assigned (0 allocated)
      Jacobian size: 0x0
      Independent indices:
      Dependent indices:  
      Parallel Jacobian calculation not available
====================================================================
In terms of run-time errors, all tests were passed

########################################################
### test_fixed_arrays
########################################################

Testing INACTIVE arrays
====================================================================
   TESTING BASIC EXPRESSIONS
--------------------------------------------------------------------
### Vector assignment to vector
### v = w
myVector3 v = {2, 3, 5}
myVector3 w = {7, 11, 13}
Evaluating v = w
Result: v = {7, 11, 13}
--------------------------------------------------------------------
### Vector assignment to expression
### v = log(w) + 1.0
myVector3 v = {2, 3, 5}
myVector3 w = {7, 11, 13}
Evaluating v = log(w) + 1.0
Result: v = {2.94591, 3.3979, 3.56495}
--------------------------------------------------------------------
### Matrix *= operator
### M *= 0.5
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M *= 0.5
Result: M = 
{{1, 1.5, 2.5},
 {3.5, 5.5, 6.5}}
--------------------------------------------------------------------
### Matrix = scalar
### M = x
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myReal x = -2
Evaluating M = x
Result: M = 
{{-2, -2, -2},
 {-2, -2, -2}}
--------------------------------------------------------------------
### Matrix = scalar expression
### M = (10.0*x)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myReal x = -2
Evaluating M = (10.0*x)
Result: M = 
{{-20, -20, -20},
 {-20, -20, -20}}
====================================================================
   TESTING BASIC FUNCTIONS
--------------------------------------------------------------------
### max
### v = max(v,w/3.0)
myVector3 v = {2, 3, 5}
myVector3 w = {7, 11, 13}
Evaluating v = max(v,w/3.0)
Result: v = {2.33333, 3.66667, 5}
--------------------------------------------------------------------
### min
### v = min(v,w/3.0)
myVector3 v = {2, 3, 5}
myVector3 w = {7, 11, 13}
Evaluating v = min(v,w/3.0)
Result: v = {2, 3, 4.33333}
====================================================================
   TESTING ARRAY SLICING
--------------------------------------------------------------------
### Array indexing rvalue
### x = M(1,end-1)
myReal x = -2
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = M(1,end-1)
Result: x = 11
--------------------------------------------------------------------
### Array indexing rvalue out of range (SHOULD FAIL)
### x = M(1,3)
myReal x = -2
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = M(1,3)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Array indexing lvalue
### M(1,end-1) *= -1.0
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(1,end-1) *= -1.0
Result: M = 
{{2, 3, 5},
 {7, -11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue
### v = M(end,__)
myVector3 v = {2, 3, 5}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = M(end,__)
Result: v = {7, 11, 13}
--------------------------------------------------------------------
### contiguous subarray lvalue
### M(end-1,__) /= 2.0
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(end-1,__) /= 2.0
Result: M = 
{{1, 1.5, 2.5},
 {7, 11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue using range
### z = 2.0 * M(1,range(1,2))
myVector2 z = {37, 47}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating z = 2.0 * M(1,range(1,2))
Result: z = {22, 26}
--------------------------------------------------------------------
### contiguous subarray lvalue using range
### M(end-1,range(0,1)) = log(v(range(1,2)))
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector3 v = {2, 3, 5}
Evaluating M(end-1,range(0,1)) = log(v(range(1,2)))
Result: M = 
{{1.09861, 1.60944, 5},
 {7, 11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue using subset
### K = 2.0 * N.subset(1,1,1,2)
myMatrix12 K = 
{{57, 59}}
myMatrix23 N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating K = 2.0 * N.subset(1,1,1,2)
Result: K = 
{{62, 74}}
--------------------------------------------------------------------
### contiguous subarray lvalue using subset
### v.subset(end-1,end) *= 10.0
myVector3 v = {2, 3, 5}
Evaluating v.subset(end-1,end) *= 10.0
Result: v = {2, 30, 50}
--------------------------------------------------------------------
### regular subarray rvalue
### v = w(stride(end,0,-1))
myVector3 v = {2, 3, 5}
myVector3 w = {7, 11, 13}
Evaluating v = w(stride(end,0,-1))
Result: v = {13, 11, 7}
--------------------------------------------------------------------
### regular subarray lvalue
### M(0,stride(0,end,2)) *= w(stride(end,0,-2))
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector3 w = {7, 11, 13}
Evaluating M(0,stride(0,end,2)) *= w(stride(end,0,-2))
Result: M = 
{{26, 3, 35},
 {7, 11, 13}}
--------------------------------------------------------------------
### irregular subarray rvalue
### M(stride(1,0,-1),find(M(0,__)>4)) = 0
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(stride(1,0,-1),find(M(0,__)>4)) = 0
Result: M = 
{{2, 3, 0},
 {7, 11, 0}}
--------------------------------------------------------------------
### slice leading dimension
### M[end] = 0
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M[end] = 0
Result: M = 
{{2, 3, 5},
 {0, 0, 0}}
--------------------------------------------------------------------
### slice two dimensions
### M[end][0] = 0
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M[end][0] = 0
Result: M = 
{{2, 3, 5},
 {0, 11, 13}}
--------------------------------------------------------------------
### diag_vector member function as rvalue
### z = diag_vector(S,1)
myVector2 z = {37, 47}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating z = diag_vector(S,1)
Result: z = {3, 13}
--------------------------------------------------------------------
### diag_vector member function as lvalue
### S.diag_vector() += v
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myVector3 v = {2, 3, 5}
Evaluating S.diag_vector() += v
Result: S = 
{{4, 3, 5},
 {7, 14, 13},
 {17, 19, 28}}
--------------------------------------------------------------------
### diag_matrix member function
### S = v.diag_matrix()
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myVector3 v = {2, 3, 5}
Evaluating S = v.diag_matrix()
Result: S = 
{{2, 0, 0},
 {0, 3, 0},
 {0, 0, 5}}
--------------------------------------------------------------------
### diag_matrix external function
### S = diag_matrix(v)
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myVector3 v = {2, 3, 5}
Evaluating S = diag_matrix(v)
Result: S = 
{{2, 0, 0},
 {0, 3, 0},
 {0, 0, 5}}
--------------------------------------------------------------------
### transpose as rvalue via T member function
### A = 2 * M.T()
myMatrix32 A = 
{{21, 22},
 {23, 24},
 {25, 26}}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating A = 2 * M.T()
Result: A = 
{{4, 14},
 {6, 22},
 {10, 26}}
--------------------------------------------------------------------
### transpose as rvalue via permute member function
### A = 2 * M.permute(1,0)
myMatrix32 A = 
{{21, 22},
 {23, 24},
 {25, 26}}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating A = 2 * M.permute(1,0)
Result: A = 
{{4, 14},
 {6, 22},
 {10, 26}}
--------------------------------------------------------------------
### 2D arbitrary index as rvalue
### B = N(index,index)
myMatrix22 B = 
{{31, 32},
 {33, 34}}
myMatrix23 N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating B = N(index,index)
Result: B = 
{{31, 29},
 {19, 17}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue
### M(index,index) = N(__,range(1,2))
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix23 N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating M(index,index) = N(__,range(1,2))
Result: M = 
{{37, 31, 5},
 {23, 19, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with assign-multiply operator
### M(index,index) *= 10.0
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
intVector index = {1, 0}
Evaluating M(index,index) *= 10.0
Result: M = 
{{20, 30, 5},
 {70, 110, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with aliased right-hand-side
### M(index,index) += M(__,range(1,2))
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
intVector index = {1, 0}
Evaluating M(index,index) += M(__,range(1,2))
Result: M = 
{{15, 14, 5},
 {12, 14, 13}}
====================================================================
   TESTING REDUCTION OPERATIONS
--------------------------------------------------------------------
### full reduction
### x = sum(M)
myReal x = -2
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = sum(M)
Result: x = 41
--------------------------------------------------------------------
### 1-dimension reduction
### v = 0.5 * mean(M,0)
myVector3 v = {2, 3, 5}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = 0.5 * mean(M,0)
Result: v = {2.25, 3.5, 4.5}
--------------------------------------------------------------------
### 1-dimension reduction
### z = norm2(M,1)
myVector2 z = {37, 47}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating z = norm2(M,1)
Result: z = {6.16441, 18.412}
--------------------------------------------------------------------
### maxval
### z = maxval(M,1)
myVector2 z = {37, 47}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating z = maxval(M,1)
Result: z = {5, 13}
--------------------------------------------------------------------
### minval
### z = minval(M,1)
myVector2 z = {37, 47}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating z = minval(M,1)
Result: z = {2, 7}
--------------------------------------------------------------------
### dot product
### x = dot_product(w,w(stride(end,0,-1)))
myReal x = -2
myVector3 w = {7, 11, 13}
Evaluating x = dot_product(w,w(stride(end,0,-1)))
Result: x = 303
--------------------------------------------------------------------
### 1D interpolation
### v = interp(value(v), w, value(w)/3.0)
myVector3 v = {2, 3, 5}
myVector3 w = {7, 11, 13}
Evaluating v = interp(value(v), w, value(w)/3.0)
Result: v = {8.33333, 11.6667, 12.3333}
====================================================================
   TESTING CONDITIONAL OPERATIONS
--------------------------------------------------------------------
### where construct, scalar right-hand-side
### M.where(N > 20) = 0
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix23 N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = 0
Result: M = 
{{2, 3, 0},
 {0, 0, 0}}
--------------------------------------------------------------------
### where construct, expression right-hand-side
### M.where(N > 20) = -N
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix23 N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = -N
Result: M = 
{{2, 3, -23},
 {-29, -31, -37}}
--------------------------------------------------------------------
### where construct, scalar either-or right-hand-side
### M.where(N > 20) = either_or(0,1)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix23 N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = either_or(0,1)
Result: M = 
{{1, 1, 0},
 {0, 0, 0}}
--------------------------------------------------------------------
### where construct, expression either-or right-hand-side
### M.where(N > 20) = either_or(-N,N)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix23 N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = either_or(-N,N)
Result: M = 
{{17, 19, -23},
 {-29, -31, -37}}
--------------------------------------------------------------------
### find construct, scalar right-hand-side
### v(find(v > 3.5)) = 0
myVector3 v = {2, 3, 5}
Evaluating v(find(v > 3.5)) = 0
Result: v = {2, 3, 0}
--------------------------------------------------------------------
### find construct, expression right-hand-side
### v(find(v > 3.5)) = -v(range(end,end))
myVector3 v = {2, 3, 5}
Evaluating v(find(v > 3.5)) = -v(range(end,end))
Result: v = {2, 3, -5}
--------------------------------------------------------------------
### find construct, multiply-assign right-hand-side
### v(find(v != 5.0)) *= 10.0
myVector3 v = {2, 3, 5}
Evaluating v(find(v != 5.0)) *= 10.0
Result: v = {20, 30, 5}
====================================================================
   TESTING SPECIAL SQUARE MATRICES
--------------------------------------------------------------------
### SymmMatrix assign from fixed matrix
### O = S
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating O = S
Result: O = 
{{2, 7, 17},
 {7, 11, 19},
 {17, 19, 23}}
--------------------------------------------------------------------
### DiagMatrix assign from dense matrix
### D = S
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating D = S
Result: D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### TridiagMatrix assign from dense matrix
### T = S
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating T = S
Result: T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
--------------------------------------------------------------------
### LowerMatrix assign from dense matrix
### L = S
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating L = S
Result: L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
--------------------------------------------------------------------
### UpperMatrix assign from dense matrix
### U = S
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating U = S
Result: U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
--------------------------------------------------------------------
### SymmMatrix as rvalue
### S = O
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating S = O
Result: S = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
--------------------------------------------------------------------
### DiagMatrix as rvalue
### S = D
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating S = D
Result: S = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### TridiagMatrix as rvalue
### S = T
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating S = T
Result: S = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
--------------------------------------------------------------------
### LowerMatrix as rvalue
### S = L
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating S = L
Result: S = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
--------------------------------------------------------------------
### UpperMatrix as rvalue
### S = U
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating S = U
Result: S = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function
### B = S.submatrix_on_diagonal(1,2)
myMatrix22 B = 
{{31, 32},
 {33, 34}}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating B = S.submatrix_on_diagonal(1,2)
Result: B = 
{{11, 13},
 {19, 23}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function as lvalue
### S.submatrix_on_diagonal(0,1) = 0
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating S.submatrix_on_diagonal(0,1) = 0
Result: S = 
{{0, 0, 5},
 {0, 0, 13},
 {17, 19, 23}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function to non-square matrix
### B = N.submatrix_on_diagonal(1,2)
myMatrix22 B = 
{{31, 32},
 {33, 34}}
*** Failed with: Expr[2,3] object assigned to FixedMatrix[3,3] (in ../include/adept/FixedArray.h:270)
*** Correct behaviour
====================================================================
   TESTING MATRIX MULTIPLICATION
--------------------------------------------------------------------
### Matrix-Matrix multiplication
### S = M.T() ** M
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating S = M.T() ** M
Result: S = 
{{53, 83, 101},
 {83, 130, 158},
 {101, 158, 194}}
--------------------------------------------------------------------
### Matrix-Matrix multiplication with matmul
### S = matmul(M.T(), M)
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating S = matmul(M.T(), M)
Result: S = 
{{53, 83, 101},
 {83, 130, 158},
 {101, 158, 194}}
--------------------------------------------------------------------
### Matrix-Matrix multiplication with inner dimension mismatch
### S = M ** M
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating S = M ** M
*** Failed with: Inner dimension mismatch in array multiplication (in ../include/adept/matmul.h:36)
*** Correct behaviour
--------------------------------------------------------------------
### Matrix-Matrix-Vector multiplication
### v = S ** S ** v
myVector3 v = {2, 3, 5}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = S ** S ** v
Result: v = {1442, 4176, 7512}
--------------------------------------------------------------------
### Matrix-Matrix-Vector multiplication
### v = S ** log(S) ** S(0,__)
myVector3 v = {2, 3, 5}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = S ** log(S) ** S(0,__)
Result: v = {248.075, 744.422, 1364.77}
--------------------------------------------------------------------
### Vector-Matrix multiplication
### v = v ** S
myVector3 v = {2, 3, 5}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = v ** S
Result: v = {110, 134, 164}
--------------------------------------------------------------------
### Vector-Matrix multiplication with matmul
### v = matmul(v, S)
myVector3 v = {2, 3, 5}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = matmul(v, S)
Result: v = {110, 134, 164}
--------------------------------------------------------------------
### SymmMatrix-Vector multiplication
### v = O ** v
myVector3 v = {2, 3, 5}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating v = O ** v
Result: v = {35, 62, 86}
--------------------------------------------------------------------
### SymmMatrix-Matrix multiplication
### S = O ** S
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating S = O ** S
Result: S = 
{{79, 100, 130},
 {166, 222, 268},
 {262, 311, 379}}
--------------------------------------------------------------------
### Vector-SymmMatrix multiplication
### v = v ** O
myVector3 v = {2, 3, 5}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating v = v ** O
Result: v = {35, 62, 86}
--------------------------------------------------------------------
### Matrix-SymmMatrix multiplication
### M = M ** O
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating M = M ** O
Result: M = 
{{35, 62, 86},
 {110, 200, 245}}
--------------------------------------------------------------------
### DiagMatrix-Vector multiplication
### v = D ** v
myVector3 v = {2, 3, 5}
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating v = D ** v
Result: v = {4, 33, 115}
--------------------------------------------------------------------
### TridiagMatrix-Vector multiplication
### v = T ** v
myVector3 v = {2, 3, 5}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating v = T ** v
Result: v = {13, 112, 172}
--------------------------------------------------------------------
### TridiagMatrix-Matrix multiplication
### S = T ** S
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating S = T ** S
Result: S = 
{{25, 39, 49},
 {312, 389, 477},
 {524, 646, 776}}
--------------------------------------------------------------------
### Vector-TridiagMatrix multiplication
### v = v ** T
myVector3 v = {2, 3, 5}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating v = v ** T
Result: v = {25, 134, 154}
--------------------------------------------------------------------
### Matrix-TridiagMatrix multiplication
### M = M ** T
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating M = M ** T
Result: M = 
{{25, 134, 154},
 {91, 389, 442}}
====================================================================
   TESTING LINEAR ALGEBRA
--------------------------------------------------------------------
### Solving general linear equations Ax=b
### v = solve(S,v)
myVector3 v = {2, 3, 5}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = solve(S,v)
Result: v = {-0.128205, -0.615385, 0.820513}
--------------------------------------------------------------------
### Solving general linear equations AX=B
### M.T() = solve(S,M.T())
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating M.T() = solve(S,M.T())
Result: M = 
{{2, 3, 5},
 {7, 11, 13}}
--------------------------------------------------------------------
### Solving linear equations Ax=b with symmetric A
### v = solve(O,v)
myVector3 v = {2, 3, 5}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating v = solve(O,v)
Result: v = {0.119728, 0.107483, 0.315646}
--------------------------------------------------------------------
### Solving linear equations AX=B with symmetric A
### M.T() = solve(O,M.T())
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating M.T() = solve(O,M.T())
Result: M = 
{{2, 3, 5},
 {7, 11, 13}}
--------------------------------------------------------------------
### Invert general matrix
### C = inv(S)
myMatrix33 C = 
{{0, 0, 0},
 {0, 0, 0},
 {0, 0, 0}}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating C = inv(S)
Result: C = 
{{-0.0769231, -0.333333, 0.205128},
 {-0.769231, 0.5, -0.115385},
 {0.692308, -0.166667, -0.0128205}}
====================================================================
   TESTING FILLING ARRAYS
--------------------------------------------------------------------
### Fill vector with "<<"
### (v << 0.1, 0.2)
myVector3 v = {2, 3, 5}
Evaluating (v << 0.1, 0.2)
Result: v = {0.1, 0.2, 5}
--------------------------------------------------------------------
### Overfill vector with "<<"
### (v << 0.1, 0.2, 0.3, 0.4)
myVector3 v = {2, 3, 5}
Evaluating (v << 0.1, 0.2, 0.3, 0.4)
*** Failed with: Row overflow in filling Vector with "<<" (in ../include/adept/Allocator.h:132)
*** Correct behaviour
--------------------------------------------------------------------
### Underfill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5)
Result: M = 
{{0.1, 0.2, 0.3},
 {0.4, 0.5, 13}}
--------------------------------------------------------------------
### Fill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6)
Result: M = 
{{0.1, 0.2, 0.3},
 {0.4, 0.5, 0.6}}
--------------------------------------------------------------------
### Overfill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
*** Failed with: Dimension overflow in filling array with "<<" (in ../include/adept/Allocator.h:154)
*** Correct behaviour
--------------------------------------------------------------------
### Fill vector with vectors using "<<"
### v << v(range(1,2)) << 0.1
myVector3 v = {2, 3, 5}
Evaluating v << v(range(1,2)) << 0.1
Result: v = {3, 5, 0.1}
--------------------------------------------------------------------
### Fill matrix with vector using "<<"
### M << 0.1 << 0.2 << 0.3 << v
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector3 v = {2, 3, 5}
Evaluating M << 0.1 << 0.2 << 0.3 << v
Result: M = 
{{0.1, 0.2, 0.3},
 {2, 3, 5}}
--------------------------------------------------------------------
### Fill matrix with vector using "<<"
### S << v << v << v
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myVector3 v = {2, 3, 5}
Evaluating S << v << v << v
Result: S = 
{{2, 3, 5},
 {2, 3, 5},
 {2, 3, 5}}
--------------------------------------------------------------------
### Assign array using range
### v = range(3,5)
myVector3 v = {2, 3, 5}
Evaluating v = range(3,5)
Result: v = {3, 4, 5}
====================================================================
   TESTING BOUNDS CHECKING
--------------------------------------------------------------------
### Access vector out of bounds
### v(0) = v(4)
myVector3 v = {2, 3, 5}
Evaluating v(0) = v(4)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Access vector out of bounds
### v(0) = v(end-4)
myVector3 v = {2, 3, 5}
Evaluating v(0) = v(end-4)
*** Failed with: Array index (probably generated from a scalar expression containing "end") is out of bounds (in ../include/adept/RangeIndex.h:128)
*** Correct behaviour
--------------------------------------------------------------------
### Access matrix out of bounds
### M(0,0) = M(0,-1)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(0,0) = M(0,-1)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Access matrix out of bounds
### M(0,0) = M(end+1,1)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(0,0) = M(end+1,1)
*** Failed with: Array index (probably generated from a scalar expression containing "end") is out of bounds (in ../include/adept/RangeIndex.h:128)
*** Correct behaviour
====================================================================
In terms of run-time errors, all tests were passed

########################################################
### test_fixed_arrays_active
########################################################

Testing ACTIVE arrays
====================================================================
   TESTING BASIC EXPRESSIONS
--------------------------------------------------------------------
### Vector assignment to vector
### v = w
myVector3 v = {2, 3, 5}
myVector3 w = {7, 11, 13}
Evaluating v = w
Result: v = {7, 11, 13}
--------------------------------------------------------------------
### Vector assignment to expression
### v = log(w) + 1.0
myVector3 v = {2, 3, 5}
myVector3 w = {7, 11, 13}
Evaluating v = log(w) + 1.0
Result: v = {2.94591, 3.3979, 3.56495}
--------------------------------------------------------------------
### Matrix *= operator
### M *= 0.5
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M *= 0.5
Result: M = 
{{1, 1.5, 2.5},
 {3.5, 5.5, 6.5}}
--------------------------------------------------------------------
### Matrix = scalar
### M = x
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myReal x = -2
Evaluating M = x
Result: M = 
{{-2, -2, -2},
 {-2, -2, -2}}
--------------------------------------------------------------------
### Matrix = scalar expression
### M = (10.0*x)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myReal x = -2
Evaluating M = (10.0*x)
Result: M = 
{{-20, -20, -20},
 {-20, -20, -20}}
====================================================================
   TESTING BASIC FUNCTIONS
--------------------------------------------------------------------
### max
### v = max(v,w/3.0)
myVector3 v = {2, 3, 5}
myVector3 w = {7, 11, 13}
Evaluating v = max(v,w/3.0)
Result: v = {2.33333, 3.66667, 5}
--------------------------------------------------------------------
### min
### v = min(v,w/3.0)
myVector3 v = {2, 3, 5}
myVector3 w = {7, 11, 13}
Evaluating v = min(v,w/3.0)
Result: v = {2, 3, 4.33333}
====================================================================
   TESTING ARRAY SLICING
--------------------------------------------------------------------
### Array indexing rvalue
### x = M(1,end-1)
myReal x = -2
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = M(1,end-1)
Result: x = 11
--------------------------------------------------------------------
### Array indexing rvalue out of range (SHOULD FAIL)
### x = M(1,3)
myReal x = -2
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = M(1,3)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Array indexing lvalue
### M(1,end-1) *= -1.0
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(1,end-1) *= -1.0
Result: M = 
{{2, 3, 5},
 {7, -11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue
### v = M(end,__)
myVector3 v = {2, 3, 5}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = M(end,__)
Result: v = {7, 11, 13}
--------------------------------------------------------------------
### contiguous subarray lvalue
### M(end-1,__) /= 2.0
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(end-1,__) /= 2.0
Result: M = 
{{1, 1.5, 2.5},
 {7, 11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue using range
### z = 2.0 * M(1,range(1,2))
myVector2 z = {37, 47}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating z = 2.0 * M(1,range(1,2))
Result: z = {22, 26}
--------------------------------------------------------------------
### contiguous subarray lvalue using range
### M(end-1,range(0,1)) = log(v(range(1,2)))
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector3 v = {2, 3, 5}
Evaluating M(end-1,range(0,1)) = log(v(range(1,2)))
Result: M = 
{{1.09861, 1.60944, 5},
 {7, 11, 13}}
--------------------------------------------------------------------
### contiguous subarray rvalue using subset
### K = 2.0 * N.subset(1,1,1,2)
myMatrix12 K = 
{{57, 59}}
myMatrix23 N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating K = 2.0 * N.subset(1,1,1,2)
Result: K = 
{{62, 74}}
--------------------------------------------------------------------
### contiguous subarray lvalue using subset
### v.subset(end-1,end) *= 10.0
myVector3 v = {2, 3, 5}
Evaluating v.subset(end-1,end) *= 10.0
Result: v = {2, 30, 50}
--------------------------------------------------------------------
### regular subarray rvalue
### v = w(stride(end,0,-1))
myVector3 v = {2, 3, 5}
myVector3 w = {7, 11, 13}
Evaluating v = w(stride(end,0,-1))
Result: v = {13, 11, 7}
--------------------------------------------------------------------
### regular subarray lvalue
### M(0,stride(0,end,2)) *= w(stride(end,0,-2))
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector3 w = {7, 11, 13}
Evaluating M(0,stride(0,end,2)) *= w(stride(end,0,-2))
Result: M = 
{{26, 3, 35},
 {7, 11, 13}}
--------------------------------------------------------------------
### irregular subarray rvalue
### M(stride(1,0,-1),find(M(0,__)>4)) = 0
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(stride(1,0,-1),find(M(0,__)>4)) = 0
Result: M = 
{{2, 3, 0},
 {7, 11, 0}}
--------------------------------------------------------------------
### slice leading dimension
### M[end] = 0
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M[end] = 0
Result: M = 
{{2, 3, 5},
 {0, 0, 0}}
--------------------------------------------------------------------
### slice two dimensions
### M[end][0] = 0
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M[end][0] = 0
Result: M = 
{{2, 3, 5},
 {0, 11, 13}}
--------------------------------------------------------------------
### diag_vector member function as rvalue
### z = diag_vector(S,1)
myVector2 z = {37, 47}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating z = diag_vector(S,1)
Result: z = {3, 13}
--------------------------------------------------------------------
### diag_vector member function as lvalue
### S.diag_vector() += v
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myVector3 v = {2, 3, 5}
Evaluating S.diag_vector() += v
Result: S = 
{{4, 3, 5},
 {7, 14, 13},
 {17, 19, 28}}
--------------------------------------------------------------------
### diag_matrix member function
### S = v.diag_matrix()
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myVector3 v = {2, 3, 5}
Evaluating S = v.diag_matrix()
Result: S = 
{{2, 0, 0},
 {0, 3, 0},
 {0, 0, 5}}
--------------------------------------------------------------------
### diag_matrix external function
### S = diag_matrix(v)
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myVector3 v = {2, 3, 5}
Evaluating S = diag_matrix(v)
Result: S = 
{{2, 0, 0},
 {0, 3, 0},
 {0, 0, 5}}
--------------------------------------------------------------------
### transpose as rvalue via T member function
### A = 2 * M.T()
myMatrix32 A = 
{{21, 22},
 {23, 24},
 {25, 26}}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating A = 2 * M.T()
Result: A = 
{{4, 14},
 {6, 22},
 {10, 26}}
--------------------------------------------------------------------
### transpose as rvalue via permute member function
### A = 2 * M.permute(1,0)
myMatrix32 A = 
{{21, 22},
 {23, 24},
 {25, 26}}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating A = 2 * M.permute(1,0)
Result: A = 
{{4, 14},
 {6, 22},
 {10, 26}}
--------------------------------------------------------------------
### 2D arbitrary index as rvalue
### B = N(index,index)
myMatrix22 B = 
{{31, 32},
 {33, 34}}
myMatrix23 N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating B = N(index,index)
Result: B = 
{{31, 29},
 {19, 17}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue
### M(index,index) = N(__,range(1,2))
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix23 N = 
{{17, 19, 23},
 {29, 31, 37}}
intVector index = {1, 0}
Evaluating M(index,index) = N(__,range(1,2))
Result: M = 
{{37, 31, 5},
 {23, 19, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with assign-multiply operator
### M(index,index) *= 10.0
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
intVector index = {1, 0}
Evaluating M(index,index) *= 10.0
Result: M = 
{{20, 30, 5},
 {70, 110, 13}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with aliased right-hand-side
### M(index,index) += M(__,range(1,2))
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
intVector index = {1, 0}
Evaluating M(index,index) += M(__,range(1,2))
Result: M = 
{{15, 14, 5},
 {12, 14, 13}}
====================================================================
   TESTING REDUCTION OPERATIONS
--------------------------------------------------------------------
### full reduction
### x = sum(M)
myReal x = -2
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating x = sum(M)
Result: x = 41
--------------------------------------------------------------------
### 1-dimension reduction
### v = 0.5 * mean(M,0)
myVector3 v = {2, 3, 5}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating v = 0.5 * mean(M,0)
Result: v = {2.25, 3.5, 4.5}
--------------------------------------------------------------------
### 1-dimension reduction
### z = norm2(M,1)
myVector2 z = {37, 47}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating z = norm2(M,1)
Result: z = {6.16441, 18.412}
--------------------------------------------------------------------
### maxval
### z = maxval(M,1)
myVector2 z = {37, 47}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating z = maxval(M,1)
Result: z = {5, 13}
--------------------------------------------------------------------
### minval
### z = minval(M,1)
myVector2 z = {37, 47}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating z = minval(M,1)
Result: z = {2, 7}
--------------------------------------------------------------------
### dot product
### x = dot_product(w,w(stride(end,0,-1)))
myReal x = -2
myVector3 w = {7, 11, 13}
Evaluating x = dot_product(w,w(stride(end,0,-1)))
Result: x = 303
--------------------------------------------------------------------
### 1D interpolation
### v = interp(value(v), w, value(w)/3.0)
myVector3 v = {2, 3, 5}
myVector3 w = {7, 11, 13}
Evaluating v = interp(value(v), w, value(w)/3.0)
Result: v = {8.33333, 11.6667, 12.3333}
====================================================================
   TESTING CONDITIONAL OPERATIONS
--------------------------------------------------------------------
### where construct, scalar right-hand-side
### M.where(N > 20) = 0
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix23 N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = 0
Result: M = 
{{2, 3, 0},
 {0, 0, 0}}
--------------------------------------------------------------------
### where construct, expression right-hand-side
### M.where(N > 20) = -N
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix23 N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = -N
Result: M = 
{{2, 3, -23},
 {-29, -31, -37}}
--------------------------------------------------------------------
### where construct, scalar either-or right-hand-side
### M.where(N > 20) = either_or(0,1)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix23 N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = either_or(0,1)
Result: M = 
{{1, 1, 0},
 {0, 0, 0}}
--------------------------------------------------------------------
### where construct, expression either-or right-hand-side
### M.where(N > 20) = either_or(-N,N)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myMatrix23 N = 
{{17, 19, 23},
 {29, 31, 37}}
Evaluating M.where(N > 20) = either_or(-N,N)
Result: M = 
{{17, 19, -23},
 {-29, -31, -37}}
--------------------------------------------------------------------
### find construct, scalar right-hand-side
### v(find(v > 3.5)) = 0
myVector3 v = {2, 3, 5}
Evaluating v(find(v > 3.5)) = 0
Result: v = {2, 3, 0}
--------------------------------------------------------------------
### find construct, expression right-hand-side
### v(find(v > 3.5)) = -v(range(end,end))
myVector3 v = {2, 3, 5}
Evaluating v(find(v > 3.5)) = -v(range(end,end))
Result: v = {2, 3, -5}
--------------------------------------------------------------------
### find construct, multiply-assign right-hand-side
### v(find(v != 5.0)) *= 10.0
myVector3 v = {2, 3, 5}
Evaluating v(find(v != 5.0)) *= 10.0
Result: v = {20, 30, 5}
====================================================================
   TESTING SPECIAL SQUARE MATRICES
--------------------------------------------------------------------
### SymmMatrix assign from fixed matrix
### O = S
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating O = S
Result: O = 
{{2, 7, 17},
 {7, 11, 19},
 {17, 19, 23}}
--------------------------------------------------------------------
### DiagMatrix assign from dense matrix
### D = S
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating D = S
Result: D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### TridiagMatrix assign from dense matrix
### T = S
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating T = S
Result: T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
--------------------------------------------------------------------
### LowerMatrix assign from dense matrix
### L = S
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating L = S
Result: L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
--------------------------------------------------------------------
### UpperMatrix assign from dense matrix
### U = S
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating U = S
Result: U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
--------------------------------------------------------------------
### SymmMatrix as rvalue
### S = O
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating S = O
Result: S = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
--------------------------------------------------------------------
### DiagMatrix as rvalue
### S = D
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating S = D
Result: S = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
--------------------------------------------------------------------
### TridiagMatrix as rvalue
### S = T
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating S = T
Result: S = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
--------------------------------------------------------------------
### LowerMatrix as rvalue
### S = L
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myLowerMatrix L = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
Evaluating S = L
Result: S = 
{{2, 0, 0},
 {7, 11, 0},
 {17, 19, 23}}
--------------------------------------------------------------------
### UpperMatrix as rvalue
### S = U
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myUpperMatrix U = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
Evaluating S = U
Result: S = 
{{2, 3, 5},
 {0, 11, 13},
 {0, 0, 23}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function
### B = S.submatrix_on_diagonal(1,2)
myMatrix22 B = 
{{31, 32},
 {33, 34}}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating B = S.submatrix_on_diagonal(1,2)
Result: B = 
{{11, 13},
 {19, 23}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function as lvalue
### S.submatrix_on_diagonal(0,1) = 0
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating S.submatrix_on_diagonal(0,1) = 0
Result: S = 
{{0, 0, 5},
 {0, 0, 13},
 {17, 19, 23}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function to non-square matrix
### B = N.submatrix_on_diagonal(1,2)
myMatrix22 B = 
{{31, 32},
 {33, 34}}
*** Failed with: Expr[2,3] object assigned to aFixedMatrix[3,3] (in ../include/adept/FixedArray.h:270)
*** Correct behaviour
====================================================================
   TESTING MATRIX MULTIPLICATION
--------------------------------------------------------------------
### Matrix-Matrix multiplication
### S = M.T() ** M
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating S = M.T() ** M
Result: S = 
{{53, 83, 101},
 {83, 130, 158},
 {101, 158, 194}}
--------------------------------------------------------------------
### Matrix-Matrix multiplication with matmul
### S = matmul(M.T(), M)
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating S = matmul(M.T(), M)
Result: S = 
{{53, 83, 101},
 {83, 130, 158},
 {101, 158, 194}}
--------------------------------------------------------------------
### Matrix-Matrix multiplication with inner dimension mismatch
### S = M ** M
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating S = M ** M
*** Failed with: Inner dimension mismatch in array multiplication (in ../include/adept/matmul.h:36)
*** Correct behaviour
--------------------------------------------------------------------
### Matrix-Matrix-Vector multiplication
### v = S ** S ** v
myVector3 v = {2, 3, 5}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = S ** S ** v
Result: v = {1442, 4176, 7512}
--------------------------------------------------------------------
### Matrix-Matrix-Vector multiplication
### v = S ** log(S) ** S(0,__)
myVector3 v = {2, 3, 5}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = S ** log(S) ** S(0,__)
Result: v = {248.075, 744.422, 1364.77}
--------------------------------------------------------------------
### Vector-Matrix multiplication
### v = v ** S
myVector3 v = {2, 3, 5}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = v ** S
Result: v = {110, 134, 164}
--------------------------------------------------------------------
### Vector-Matrix multiplication with matmul
### v = matmul(v, S)
myVector3 v = {2, 3, 5}
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
Evaluating v = matmul(v, S)
Result: v = {110, 134, 164}
--------------------------------------------------------------------
### SymmMatrix-Vector multiplication
### v = O ** v
myVector3 v = {2, 3, 5}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating v = O ** v
Result: v = {35, 62, 86}
--------------------------------------------------------------------
### SymmMatrix-Matrix multiplication
### S = O ** S
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating S = O ** S
Result: S = 
{{79, 100, 130},
 {166, 222, 268},
 {262, 311, 379}}
--------------------------------------------------------------------
### Vector-SymmMatrix multiplication
### v = v ** O
myVector3 v = {2, 3, 5}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating v = v ** O
Result: v = {35, 62, 86}
--------------------------------------------------------------------
### Matrix-SymmMatrix multiplication
### M = M ** O
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
mySymmMatrix O = 
{{7, 2, 3},
 {2, 11, 5},
 {3, 5, 13}}
Evaluating M = M ** O
Result: M = 
{{35, 62, 86},
 {110, 200, 245}}
--------------------------------------------------------------------
### DiagMatrix-Vector multiplication
### v = D ** v
myVector3 v = {2, 3, 5}
myDiagMatrix D = 
{{2, 0, 0},
 {0, 11, 0},
 {0, 0, 23}}
Evaluating v = D ** v
Result: v = {4, 33, 115}
--------------------------------------------------------------------
### TridiagMatrix-Vector multiplication
### v = T ** v
myVector3 v = {2, 3, 5}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating v = T ** v
Result: v = {13, 112, 172}
--------------------------------------------------------------------
### TridiagMatrix-Matrix multiplication
### S = T ** S
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating S = T ** S
Result: S = 
{{25, 39, 49},
 {312, 389, 477},
 {524, 646, 776}}
--------------------------------------------------------------------
### Vector-TridiagMatrix multiplication
### v = v ** T
myVector3 v = {2, 3, 5}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating v = v ** T
Result: v = {25, 134, 154}
--------------------------------------------------------------------
### Matrix-TridiagMatrix multiplication
### M = M ** T
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myTridiagMatrix T = 
{{2, 3, 0},
 {7, 11, 13},
 {0, 19, 23}}
Evaluating M = M ** T
Result: M = 
{{25, 134, 154},
 {91, 389, 442}}
NO LINEAR ALGEBRA TESTS PERFORMED BECAUSE ACTIVE ARRAYS NOT YET SUPPORTED
====================================================================
   TESTING FILLING ARRAYS
--------------------------------------------------------------------
### Fill vector with "<<"
### (v << 0.1, 0.2)
myVector3 v = {2, 3, 5}
Evaluating (v << 0.1, 0.2)
Result: v = {0.1, 0.2, 5}
--------------------------------------------------------------------
### Overfill vector with "<<"
### (v << 0.1, 0.2, 0.3, 0.4)
myVector3 v = {2, 3, 5}
Evaluating (v << 0.1, 0.2, 0.3, 0.4)
*** Failed with: Row overflow in filling Vector with "<<" (in ../include/adept/Allocator.h:132)
*** Correct behaviour
--------------------------------------------------------------------
### Underfill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5)
Result: M = 
{{0.1, 0.2, 0.3},
 {0.4, 0.5, 13}}
--------------------------------------------------------------------
### Fill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6)
Result: M = 
{{0.1, 0.2, 0.3},
 {0.4, 0.5, 0.6}}
--------------------------------------------------------------------
### Overfill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
*** Failed with: Dimension overflow in filling array with "<<" (in ../include/adept/Allocator.h:154)
*** Correct behaviour
--------------------------------------------------------------------
### Fill vector with vectors using "<<"
### v << v(range(1,2)) << 0.1
myVector3 v = {2, 3, 5}
Evaluating v << v(range(1,2)) << 0.1
Result: v = {3, 5, 0.1}
--------------------------------------------------------------------
### Fill matrix with vector using "<<"
### M << 0.1 << 0.2 << 0.3 << v
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
myVector3 v = {2, 3, 5}
Evaluating M << 0.1 << 0.2 << 0.3 << v
Result: M = 
{{0.1, 0.2, 0.3},
 {2, 3, 5}}
--------------------------------------------------------------------
### Fill matrix with vector using "<<"
### S << v << v << v
myMatrix33 S = 
{{2, 3, 5},
 {7, 11, 13},
 {17, 19, 23}}
myVector3 v = {2, 3, 5}
Evaluating S << v << v << v
Result: S = 
{{2, 3, 5},
 {2, 3, 5},
 {2, 3, 5}}
--------------------------------------------------------------------
### Assign array using range
### v = range(3,5)
myVector3 v = {2, 3, 5}
Evaluating v = range(3,5)
Result: v = {3, 4, 5}
====================================================================
   TESTING BOUNDS CHECKING
--------------------------------------------------------------------
### Access vector out of bounds
### v(0) = v(4)
myVector3 v = {2, 3, 5}
Evaluating v(0) = v(4)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Access vector out of bounds
### v(0) = v(end-4)
myVector3 v = {2, 3, 5}
Evaluating v(0) = v(end-4)
*** Failed with: Array index (probably generated from a scalar expression containing "end") is out of bounds (in ../include/adept/RangeIndex.h:128)
*** Correct behaviour
--------------------------------------------------------------------
### Access matrix out of bounds
### M(0,0) = M(0,-1)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(0,0) = M(0,-1)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Access matrix out of bounds
### M(0,0) = M(end+1,1)
myMatrix23 M = 
{{2, 3, 5},
 {7, 11, 13}}
Evaluating M(0,0) = M(end+1,1)
*** Failed with: Array index (probably generated from a scalar expression containing "end") is out of bounds (in ../include/adept/RangeIndex.h:128)
*** Correct behaviour
====================================================================
In terms of run-time errors, all tests were passed

########################################################
### test_derivatives
########################################################

EVALUATING UNARY FUNCTIONS
For functions of the form y=FUNC(x), where x={0.01, 0.4, 0.99, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2},
checking that fractional difference between dy/dx computed using Adept
and numerically by perturbing x by 1e-08 is less than 1e-05.
  Checking -... 	max fractional error = 2.22507e-308: PASSED
  Checking +... 	max fractional error = 5.02476e-09: PASSED
  Checking log... 	max fractional error = 5.00793e-07: PASSED
  Checking log10... 	max fractional error = 4.99961e-07: PASSED
  Checking sin... 	max fractional error = 1.95634e-08: PASSED
  Checking cos... 	max fractional error = 2.22507e-308: PASSED
  Checking tan... 	max fractional error = 3.08018e-08: PASSED
  Checking asin... 	max fractional error = 2.53491e-07: PASSED
  Checking acos... 	max fractional error = 2.22507e-308: PASSED
  Checking atan... 	max fractional error = 5.63338e-09: PASSED
  Checking sinh... 	max fractional error = 1.34797e-08: PASSED
  Checking cosh... 	max fractional error = 1.04087e-06: PASSED
  Checking tanh... 	max fractional error = 8.44461e-09: PASSED
  Checking abs... 	max fractional error = 5.02476e-09: PASSED
  Checking fabs... 	max fractional error = 5.02476e-09: PASSED
  Checking exp... 	max fractional error = 1.92373e-08: PASSED
  Checking sqrt... 	max fractional error = 2.50049e-07: PASSED
  Checking ceil... 	max fractional error = 2.22507e-308: PASSED
  Checking floor... 	max fractional error = 2.22507e-308: PASSED
  Checking log2... 	max fractional error = 4.99984e-07: PASSED
  Checking expm1... 	max fractional error = 1.09867e-08: PASSED
  Checking exp2... 	max fractional error = 2.11166e-08: PASSED
  Checking log1p... 	max fractional error = 8.29792e-09: PASSED
  Checking asinh... 	max fractional error = 9.45831e-09: PASSED
  Checking acosh... 	max fractional error = 2.22507e-308: PASSED
  Checking atanh... 	max fractional error = 5.02565e-07: PASSED
  Checking erf... 	max fractional error = 1.78267e-08: PASSED
  Checking erfc... 	max fractional error = 2.22507e-308: PASSED
  Checking cbrt... 	max fractional error = 3.33254e-07: PASSED
  Checking round... 	max fractional error = 2.22507e-308: PASSED
  Checking trunc... 	max fractional error = 2.22507e-308: PASSED
  Checking rint... 	max fractional error = 2.22507e-308: PASSED
  Checking nearbyint... 	max fractional error = 2.22507e-308: PASSED
EVALUATING BINARY FUNCTIONS
For functions of the form z=FUNC(x,y), where x={0.01, 0.4, 0.99, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2},
and y={0.9, 0.6, 0.1, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7}, checking that fractional difference between
dz/dx and dz/dy computed using Adept and numerically by perturbing
x and y by 1e-08 is less than 1e-05.
  Checking pow... 	max fractional error = 5.01566e-08: PASSED
  Checking atan2... 	max fractional error = 1.64914e-08: PASSED
  Checking max... 	max fractional error = 5.02476e-09: PASSED
  Checking min... 	max fractional error = 5.26356e-10: PASSED
  Checking fmax... 	max fractional error = 5.02476e-09: PASSED
  Checking fmin... 	max fractional error = 5.26356e-10: PASSED

########################################################
### test_array_derivatives
########################################################

NUMERICAL CALCULATION
J = 2.89063
dJ_dx_num = 
{{-1.15516, 0.0247668},
 {0.00565937, -0.0280842}}

NUMERICAL CALCULATION WITH "FixedArray"
J = 2.89063
dJ_dx_num_FixedArray = 
{{-1.15516, 0.0247668},
 {0.00565937, -0.0280842}}

ADEPT CALCULATION WITH "aArray"
J = 2.89063
dJ_dx_adept_Array = 
{{-1.15516, 0.0247668},
 {0.00565937, -0.0280842}}
max fractional error = 5.93193e-07: PASSED

ADEPT CALCULATION WITH "aFixedArray"
J = 2.89063
dJ_dx_adept_FixedArray = 
{{-1.15516, 0.0247668},
 {0.00565937, -0.0280842}}
max fractional error = 5.93193e-07: PASSED


########################################################
### test_thread_safe_arrays
########################################################

Storage is not thread safe: using soft_link()
Compiled without OpenMP support: 1 thread
Serial subsetting of array zillions of times was successful (unsurprisingly)

########################################################
### test_complex_arrays
########################################################

Adept version 2.0.5:
  Compiled with g++ [4.2.1]
  Compiler flags "-g -O2"
  BLAS support from blas library
  Jacobians processed in blocks of size 4
Testing INACTIVE arrays
Testing COMPLEX arrays
====================================================================
   TESTING ARRAY FUNCTIONALITY
--------------------------------------------------------------------
### Array "resize" member function
### M.resize(1,5)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating M.resize(1,5)
Result: M = 
{{(0,0), (0,0), (0,0), (0,0), (0,0)}}
--------------------------------------------------------------------
### Array "resize" with invalid dimensions
### M.resize(1)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating M.resize(1)
*** Failed with: Invalid dimensions in array resize (in ../include/adept/Array.h:2015)
*** Correct behaviour
--------------------------------------------------------------------
### Array "resize" with "dimensions" function
### M.resize(dimensions(4,2))
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating M.resize(dimensions(4,2))
Result: M = 
{{(0,0), (0,0)},
 {(0,0), (0,0)},
 {(0,0), (0,0)},
 {(0,0), (0,0)}}
--------------------------------------------------------------------
### Array "clear" member function
### M.clear()
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating M.clear()
Result: M = (empty rank-2 array)
====================================================================
   TESTING BASIC EXPRESSIONS
--------------------------------------------------------------------
### Vector assignment to vector from empty
### v = w
myVector v = (empty rank-1 array)
myVector w = {(7,4), (11,0), (13,0)}
Evaluating v = w
Result: v = {(7,4), (11,0), (13,0)}
--------------------------------------------------------------------
### Vector assignment to expression from empty
### v = log(w) + 1.0
myVector v = (empty rank-1 array)
myVector w = {(7,4), (11,0), (13,0)}
Evaluating v = log(w) + 1.0
Result: v = {(3.08719,0.519146), (3.3979,0), (3.56495,0)}
--------------------------------------------------------------------
### Matrix *= operator
### M *= 0.5
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating M *= 0.5
Result: M = 
{{(1,1.5), (1.5,0), (2.5,0)},
 {(3.5,0), (5.5,0), (6.5,0)}}
--------------------------------------------------------------------
### Matrix = scalar
### M = x
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
myReal x = (-2,0)
Evaluating M = x
Result: M = 
{{(-2,0), (-2,0), (-2,0)},
 {(-2,0), (-2,0), (-2,0)}}
--------------------------------------------------------------------
### Matrix = scalar expression
### M = (10.0*x)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
myReal x = (-2,0)
Evaluating M = (10.0*x)
Result: M = 
{{(-20,0), (-20,0), (-20,0)},
 {(-20,0), (-20,0), (-20,0)}}
====================================================================
   TESTING ARRAY SLICING
--------------------------------------------------------------------
### Array indexing rvalue
### x = M(1,end-1)
myReal x = (-2,0)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating x = M(1,end-1)
Result: x = (11,0)
--------------------------------------------------------------------
### Array indexing rvalue out of range (SHOULD FAIL)
### x = M(1,3)
myReal x = (-2,0)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating x = M(1,3)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Array indexing lvalue
### M(1,end-1) *= -1.0
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating M(1,end-1) *= -1.0
Result: M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (-11,-0), (13,0)}}
--------------------------------------------------------------------
### contiguous subarray rvalue
### v = M(__,end)
myVector v = (empty rank-1 array)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating v = M(__,end)
Result: v = {(5,0), (13,0)}
--------------------------------------------------------------------
### contiguous subarray lvalue
### M(end-1,__) /= 2.0
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating M(end-1,__) /= 2.0
Result: M = 
{{(1,1.5), (1.5,0), (2.5,0)},
 {(7,0), (11,0), (13,0)}}
--------------------------------------------------------------------
### contiguous subarray rvalue and lvalue
### M(__,1) = N(__,2)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
myMatrix N = 
{{(17,5), (19,0), (23,0)},
 {(29,0), (31,0), (37,0)}}
Evaluating M(__,1) = N(__,2)
Result: M = 
{{(2,3), (23,0), (5,0)},
 {(7,0), (37,0), (13,0)}}
--------------------------------------------------------------------
### contiguous subarray rvalue using range
### v = 2.0 * M(1,range(1,2))
myVector v = (empty rank-1 array)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating v = 2.0 * M(1,range(1,2))
Result: v = {(22,0), (26,0)}
--------------------------------------------------------------------
### contiguous subarray lvalue using range
### M(end-1,range(0,1)) = log(v(range(1,2)))
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
myVector v = {(2,3), (3,0), (5,0)}
Evaluating M(end-1,range(0,1)) = log(v(range(1,2)))
Result: M = 
{{(1.09861,0), (1.60944,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
--------------------------------------------------------------------
### contiguous subarray rvalue using subset
### M = 2.0 * N.subset(1,1,1,2)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{(17,5), (19,0), (23,0)},
 {(29,0), (31,0), (37,0)}}
Evaluating M = 2.0 * N.subset(1,1,1,2)
Result: M = 
{{(62,0), (74,0)}}
--------------------------------------------------------------------
### contiguous subarray lvalue using subset
### v.subset(end-1,end) *= 10.0
myVector v = {(2,3), (3,0), (5,0)}
Evaluating v.subset(end-1,end) *= 10.0
Result: v = {(2,3), (30,0), (50,0)}
--------------------------------------------------------------------
### regular subarray rvalue
### v = w(stride(end,0,-1))
myVector v = (empty rank-1 array)
myVector w = {(7,4), (11,0), (13,0)}
Evaluating v = w(stride(end,0,-1))
Result: v = {(13,0), (11,0), (7,4)}
--------------------------------------------------------------------
### regular subarray lvalue
### M(0,stride(0,end,2)) *= w(stride(end,0,-2))
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
myVector w = {(7,4), (11,0), (13,0)}
Evaluating M(0,stride(0,end,2)) *= w(stride(end,0,-2))
Result: M = 
{{(26,39), (3,0), (35,20)},
 {(7,0), (11,0), (13,0)}}
--------------------------------------------------------------------
### slice leading dimension
### M[end] = 0
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating M[end] = 0
Result: M = 
{{(2,3), (3,0), (5,0)},
 {(0,0), (0,0), (0,0)}}
--------------------------------------------------------------------
### slice two dimensions
### M[end][0] = 0
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating M[end][0] = 0
Result: M = 
{{(2,3), (3,0), (5,0)},
 {(0,0), (11,0), (13,0)}}
--------------------------------------------------------------------
### diag_vector member function as rvalue
### v = diag_vector(S,1)
myVector v = (empty rank-1 array)
myMatrix S = 
{{(2,3), (3,0), (5,0)},
 {(7,4), (11,0), (13,0)},
 {(17,0), (19,0), (23,0)}}
Evaluating v = diag_vector(S,1)
Result: v = {(3,0), (13,0)}
--------------------------------------------------------------------
### diag_vector member function as lvalue
### S.diag_vector() += v
myMatrix S = 
{{(2,3), (3,0), (5,0)},
 {(7,4), (11,0), (13,0)},
 {(17,0), (19,0), (23,0)}}
myVector v = {(2,3), (3,0), (5,0)}
Evaluating S.diag_vector() += v
Result: S = 
{{(4,6), (3,0), (5,0)},
 {(7,4), (14,0), (13,0)},
 {(17,0), (19,0), (28,0)}}
--------------------------------------------------------------------
### diag_matrix member function
### S = v.diag_matrix()
myMatrix S = (empty rank-2 array)
myVector v = {(2,3), (3,0), (5,0)}
Evaluating S = v.diag_matrix()
Result: S = 
{{(2,3), (0,0), (0,0)},
 {(0,0), (3,0), (0,0)},
 {(0,0), (0,0), (5,0)}}
--------------------------------------------------------------------
### diag_matrix external function
### S = diag_matrix(v)
myMatrix S = (empty rank-2 array)
myVector v = {(2,3), (3,0), (5,0)}
Evaluating S = diag_matrix(v)
Result: S = 
{{(2,3), (0,0), (0,0)},
 {(0,0), (3,0), (0,0)},
 {(0,0), (0,0), (5,0)}}
--------------------------------------------------------------------
### transpose as rvalue via T member function
### N = 2.0 * M.T()
myMatrix N = (empty rank-2 array)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating N = 2.0 * M.T()
Result: N = 
{{(4,6), (14,0)},
 {(6,0), (22,0)},
 {(10,0), (26,0)}}
--------------------------------------------------------------------
### transpose as rvalue via permute member function
### N = 2.0 * M.permute(1,0)
myMatrix N = (empty rank-2 array)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating N = 2.0 * M.permute(1,0)
Result: N = 
{{(4,6), (14,0)},
 {(6,0), (22,0)},
 {(10,0), (26,0)}}
--------------------------------------------------------------------
### matrix indexing (scalar,non-contiguous)
### v = N(1,index)
myVector v = (empty rank-1 array)
myMatrix N = 
{{(17,5), (19,0), (23,0)},
 {(29,0), (31,0), (37,0)}}
intVector index = {1, 0}
Evaluating v = N(1,index)
Result: v = {(31,0), (29,0)}
--------------------------------------------------------------------
### matrix indexing (non-contiguous,scalar)
### v = N(index,1)
myVector v = (empty rank-1 array)
myMatrix N = 
{{(17,5), (19,0), (23,0)},
 {(29,0), (31,0), (37,0)}}
intVector index = {1, 0}
Evaluating v = N(index,1)
Result: v = {(31,0), (19,0)}
--------------------------------------------------------------------
### 2D arbitrary index as rvalue
### M = const_cast<const myMatrix&>(N)(index,index)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{(17,5), (19,0), (23,0)},
 {(29,0), (31,0), (37,0)}}
intVector index = {1, 0}
Evaluating M = const_cast<const myMatrix&>(N)(index,index)
Result: M = 
{{(31,0), (29,0)},
 {(19,0), (17,5)}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue assigned to scalar expression
### M(index,index) = 2.0*(myReal)(4.0)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
myMatrix N = 
{{(17,5), (19,0), (23,0)},
 {(29,0), (31,0), (37,0)}}
intVector index = {1, 0}
Evaluating M(index,index) = 2.0*(myReal)(4.0)
Result: M = 
{{(8,0), (8,0), (5,0)},
 {(8,0), (8,0), (13,0)}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue
### M(index,index) = N(__,range(1,2))
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
myMatrix N = 
{{(17,5), (19,0), (23,0)},
 {(29,0), (31,0), (37,0)}}
intVector index = {1, 0}
Evaluating M(index,index) = N(__,range(1,2))
Result: M = 
{{(37,0), (31,0), (5,0)},
 {(23,0), (19,0), (13,0)}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with assign-multiply operator
### M(index,index) *= 10.0
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
intVector index = {1, 0}
Evaluating M(index,index) *= 10.0
Result: M = 
{{(20,30), (30,0), (5,0)},
 {(70,0), (110,0), (13,0)}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with aliased right-hand-side
### M(index,index) = M(__,range(0,1))
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
intVector index = {1, 0}
Evaluating M(index,index) = M(__,range(0,1))
Result: M = 
{{(11,0), (7,0), (5,0)},
 {(3,0), (2,3), (13,0)}}
--------------------------------------------------------------------
### 2D arbitrary index as lvalue with aliased right-hand-side and eval function
### M(index,index) = eval(M(__,range(0,1)))
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
intVector index = {1, 0}
Evaluating M(index,index) = eval(M(__,range(0,1)))
Result: M = 
{{(11,0), (7,0), (5,0)},
 {(3,0), (2,3), (13,0)}}
--------------------------------------------------------------------
### reshape member function
### M >>= vlong.reshape(3,4)
myMatrix M = (empty rank-2 array)
myVector vlong = {(1,0), (2,0), (3,0), (4,0), (5,0), (6,0), (7,0), (8,0), (9,0), (10,0), (11,0), (12,0)}
Evaluating M >>= vlong.reshape(3,4)
Result: M = 
{{(1,0), (2,0), (3,0), (4,0)},
 {(5,0), (6,0), (7,0), (8,0)},
 {(9,0), (10,0), (11,0), (12,0)}}
--------------------------------------------------------------------
### reshape member function with invalid dimensions
### M >>= vlong.reshape(5,5)
myMatrix M = (empty rank-2 array)
myVector vlong = {(1,0), (2,0), (3,0), (4,0), (5,0), (6,0), (7,0), (8,0), (9,0), (10,0), (11,0), (12,0)}
Evaluating M >>= vlong.reshape(5,5)
*** Failed with: Size of reshaped array does not match original vector
*** Correct behaviour
--------------------------------------------------------------------
### end/2 indexing
### vlong(range(end/2,end)) = 0.0
myVector vlong = {(1,0), (2,0), (3,0), (4,0), (5,0), (6,0), (7,0), (8,0), (9,0), (10,0), (11,0), (12,0)}
Evaluating vlong(range(end/2,end)) = 0.0
Result: vlong = {(1,0), (2,0), (3,0), (4,0), (5,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0)}
--------------------------------------------------------------------
### end/2 indexing
### vlong(range(0,end/2)) = 0.0
myVector vlong = {(1,0), (2,0), (3,0), (4,0), (5,0), (6,0), (7,0), (8,0), (9,0), (10,0), (11,0), (12,0)}
Evaluating vlong(range(0,end/2)) = 0.0
Result: vlong = {(0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (7,0), (8,0), (9,0), (10,0), (11,0), (12,0)}
--------------------------------------------------------------------
### end/2 indexing
### vlong.subset(end/2,end) = 0.0
myVector vlong = {(1,0), (2,0), (3,0), (4,0), (5,0), (6,0), (7,0), (8,0), (9,0), (10,0), (11,0), (12,0)}
Evaluating vlong.subset(end/2,end) = 0.0
Result: vlong = {(1,0), (2,0), (3,0), (4,0), (5,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0)}
====================================================================
   TESTING REDUCTION OPERATIONS
--------------------------------------------------------------------
### full sum
### x = sum(M)
myReal x = (-2,0)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating x = sum(M)
Result: x = (41,3)
--------------------------------------------------------------------
### full product
### x = product(M)
myReal x = (-2,0)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating x = product(M)
Result: x = (30030,45045)
--------------------------------------------------------------------
### full norm2
### x = norm2(M)
myReal x = (-2,0)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating x = norm2(M)
Result: x = (19.1859,0.31273)
--------------------------------------------------------------------
### 1-dimension mean
### v = 0.5 * mean(M,0)
myVector v = (empty rank-1 array)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating v = 0.5 * mean(M,0)
Result: v = {(2.25,0.75), (3.5,0), (4.5,0)}
--------------------------------------------------------------------
### 1-dimension norm2
### v = norm2(M,1)
myVector v = (empty rank-1 array)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating v = norm2(M,1)
Result: v = {(5.49476,1.09195), (18.412,0)}
--------------------------------------------------------------------
### dot product
### x = dot_product(w,w(stride(end,0,-1)))
myReal x = (-2,0)
myVector w = {(7,4), (11,0), (13,0)}
Evaluating x = dot_product(w,w(stride(end,0,-1)))
Result: x = (303,104)
--------------------------------------------------------------------
### dot product on expressions
### x = dot_product(2.0*w,w(stride(end,0,-1))+1.0)
myReal x = (-2,0)
myVector w = {(7,4), (11,0), (13,0)}
Evaluating x = dot_product(2.0*w,w(stride(end,0,-1))+1.0)
Result: x = (668,216)
====================================================================
   TESTING SPECIAL SQUARE MATRICES
--------------------------------------------------------------------
### SymmMatrix "resize" member function
### O.resize(5)
mySymmMatrix O = 
{{(7,3), (0,0), (0,0)},
 {(2,0), (11,0), (0,0)},
 {(3,0), (5,0), (13,0)}}
Evaluating O.resize(5)
Result: O = 
{{(0,0), (0,0), (0,0), (0,0), (0,0)},
 {(0,0), (0,0), (0,0), (0,0), (0,0)},
 {(0,0), (0,0), (0,0), (0,0), (0,0)},
 {(0,0), (0,0), (0,0), (0,0), (0,0)},
 {(0,0), (0,0), (0,0), (0,0), (0,0)}}
--------------------------------------------------------------------
### SymmMatrix "resize" with invalid dimensions
### O.resize(4,5)
mySymmMatrix O = 
{{(7,3), (0,0), (0,0)},
 {(2,0), (11,0), (0,0)},
 {(3,0), (5,0), (13,0)}}
Evaluating O.resize(4,5)
*** Failed with: Square matrix must have the same x and y dimensions (in ../include/adept/SpecialMatrix.h:1527)
*** Correct behaviour
--------------------------------------------------------------------
### SymmMatrix "clear" member function
### O.clear()
mySymmMatrix O = 
{{(7,3), (0,0), (0,0)},
 {(2,0), (11,0), (0,0)},
 {(3,0), (5,0), (13,0)}}
Evaluating O.clear()
Result: O = (empty rank-2 array)
--------------------------------------------------------------------
### SymmMatrix assign from dense matrix
### O = S
mySymmMatrix O = (empty rank-2 array)
myMatrix S = 
{{(2,3), (3,0), (5,0)},
 {(7,4), (11,0), (13,0)},
 {(17,0), (19,0), (23,0)}}
Evaluating O = S
Result: O = 
{{(2,3), (3,0), (5,0)},
 {(7,4), (11,0), (13,0)},
 {(17,0), (19,0), (23,0)}}
--------------------------------------------------------------------
### DiagMatrix assign from dense matrix
### D = S
myDiagMatrix D = (empty rank-2 array)
myMatrix S = 
{{(2,3), (3,0), (5,0)},
 {(7,4), (11,0), (13,0)},
 {(17,0), (19,0), (23,0)}}
Evaluating D = S
Result: D = 
{{(2,3), (0,0), (0,0)},
 {(0,0), (11,0), (0,0)},
 {(0,0), (0,0), (23,0)}}
--------------------------------------------------------------------
### TridiagMatrix assign from dense matrix
### T = S
myTridiagMatrix T = (empty rank-2 array)
myMatrix S = 
{{(2,3), (3,0), (5,0)},
 {(7,4), (11,0), (13,0)},
 {(17,0), (19,0), (23,0)}}
Evaluating T = S
Result: T = 
{{(2,3), (3,0), (0,0)},
 {(7,4), (11,0), (13,0)},
 {(0,0), (19,0), (23,0)}}
--------------------------------------------------------------------
### LowerMatrix assign from dense matrix
### L = S
myLowerMatrix L = (empty rank-2 array)
myMatrix S = 
{{(2,3), (3,0), (5,0)},
 {(7,4), (11,0), (13,0)},
 {(17,0), (19,0), (23,0)}}
Evaluating L = S
Result: L = 
{{(2,3), (0,0), (0,0)},
 {(7,4), (11,0), (0,0)},
 {(17,0), (19,0), (23,0)}}
--------------------------------------------------------------------
### UpperMatrix assign from dense matrix
### U = S
myUpperMatrix U = (empty rank-2 array)
myMatrix S = 
{{(2,3), (3,0), (5,0)},
 {(7,4), (11,0), (13,0)},
 {(17,0), (19,0), (23,0)}}
Evaluating U = S
Result: U = 
{{(2,3), (3,0), (5,0)},
 {(0,0), (11,0), (13,0)},
 {(0,0), (0,0), (23,0)}}
--------------------------------------------------------------------
### SymmMatrix += operator
### O += 3.0
mySymmMatrix O = 
{{(7,3), (0,0), (0,0)},
 {(2,0), (11,0), (0,0)},
 {(3,0), (5,0), (13,0)}}
Evaluating O += 3.0
Result: O = 
{{(10,3), (3,0), (3,0)},
 {(5,0), (14,0), (3,0)},
 {(6,0), (8,0), (16,0)}}
--------------------------------------------------------------------
### DiagMatrix += operator
### D += 3.0
myDiagMatrix D = 
{{(2,3), (0,0), (0,0)},
 {(0,0), (11,0), (0,0)},
 {(0,0), (0,0), (23,0)}}
Evaluating D += 3.0
Result: D = 
{{(5,3), (0,0), (0,0)},
 {(0,0), (14,0), (0,0)},
 {(0,0), (0,0), (26,0)}}
--------------------------------------------------------------------
### TridiagMatrix += operator
### T += 3.0
myTridiagMatrix T = 
{{(2,3), (3,0), (0,0)},
 {(7,4), (11,0), (13,0)},
 {(0,0), (19,0), (23,0)}}
Evaluating T += 3.0
Result: T = 
{{(5,3), (6,0), (0,0)},
 {(10,4), (14,0), (16,0)},
 {(0,0), (22,0), (26,0)}}
--------------------------------------------------------------------
### LowerMatrix += operator
### L += 3.0
myLowerMatrix L = 
{{(2,3), (0,0), (0,0)},
 {(7,4), (11,0), (0,0)},
 {(17,0), (19,0), (23,0)}}
Evaluating L += 3.0
Result: L = 
{{(5,3), (0,0), (0,0)},
 {(10,4), (14,0), (0,0)},
 {(20,0), (22,0), (26,0)}}
--------------------------------------------------------------------
### UpperMatrix += operator
### U += 3.0
myUpperMatrix U = 
{{(2,3), (3,0), (5,0)},
 {(0,0), (11,0), (13,0)},
 {(0,0), (0,0), (23,0)}}
Evaluating U += 3.0
Result: U = 
{{(5,3), (6,0), (8,0)},
 {(0,0), (14,0), (16,0)},
 {(0,0), (0,0), (26,0)}}
--------------------------------------------------------------------
### SymmMatrix as rvalue
### M = O
myMatrix M = (empty rank-2 array)
mySymmMatrix O = 
{{(7,3), (0,0), (0,0)},
 {(2,0), (11,0), (0,0)},
 {(3,0), (5,0), (13,0)}}
Evaluating M = O
Result: M = 
{{(7,3), (0,0), (0,0)},
 {(2,0), (11,0), (0,0)},
 {(3,0), (5,0), (13,0)}}
--------------------------------------------------------------------
### DiagMatrix as rvalue
### M = D
myMatrix M = (empty rank-2 array)
myDiagMatrix D = 
{{(2,3), (0,0), (0,0)},
 {(0,0), (11,0), (0,0)},
 {(0,0), (0,0), (23,0)}}
Evaluating M = D
Result: M = 
{{(2,3), (0,0), (0,0)},
 {(0,0), (11,0), (0,0)},
 {(0,0), (0,0), (23,0)}}
--------------------------------------------------------------------
### TridiagMatrix as rvalue
### M = T
myMatrix M = (empty rank-2 array)
myTridiagMatrix T = 
{{(2,3), (3,0), (0,0)},
 {(7,4), (11,0), (13,0)},
 {(0,0), (19,0), (23,0)}}
Evaluating M = T
Result: M = 
{{(2,3), (3,0), (0,0)},
 {(7,4), (11,0), (13,0)},
 {(0,0), (19,0), (23,0)}}
--------------------------------------------------------------------
### LowerMatrix as rvalue
### M = L
myMatrix M = (empty rank-2 array)
myLowerMatrix L = 
{{(2,3), (0,0), (0,0)},
 {(7,4), (11,0), (0,0)},
 {(17,0), (19,0), (23,0)}}
Evaluating M = L
Result: M = 
{{(2,3), (0,0), (0,0)},
 {(7,4), (11,0), (0,0)},
 {(17,0), (19,0), (23,0)}}
--------------------------------------------------------------------
### UpperMatrix as rvalue
### M = U
myMatrix M = (empty rank-2 array)
myUpperMatrix U = 
{{(2,3), (3,0), (5,0)},
 {(0,0), (11,0), (13,0)},
 {(0,0), (0,0), (23,0)}}
Evaluating M = U
Result: M = 
{{(2,3), (3,0), (5,0)},
 {(0,0), (11,0), (13,0)},
 {(0,0), (0,0), (23,0)}}
--------------------------------------------------------------------
### SymmMatrix assign from scalar expression
### O = 2.0*(myReal)(4.0)
mySymmMatrix O = 
{{(7,3), (0,0), (0,0)},
 {(2,0), (11,0), (0,0)},
 {(3,0), (5,0), (13,0)}}
Evaluating O = 2.0*(myReal)(4.0)
Result: O = 
{{(8,0), (8,0), (8,0)},
 {(8,0), (8,0), (8,0)},
 {(8,0), (8,0), (8,0)}}
--------------------------------------------------------------------
### UpperMatrix assign from scalar expression
### U = 2.0*(myReal)(4.0)
myUpperMatrix U = 
{{(2,3), (3,0), (5,0)},
 {(0,0), (11,0), (13,0)},
 {(0,0), (0,0), (23,0)}}
Evaluating U = 2.0*(myReal)(4.0)
Result: U = 
{{(8,0), (8,0), (8,0)},
 {(0,0), (8,0), (8,0)},
 {(0,0), (0,0), (8,0)}}
--------------------------------------------------------------------
### SymmMatrix diag_vector member function as lvalue (upper)
### O.diag_vector(1) = 0
mySymmMatrix O = 
{{(7,3), (0,0), (0,0)},
 {(2,0), (11,0), (0,0)},
 {(3,0), (5,0), (13,0)}}
Evaluating O.diag_vector(1) = 0
Result: O = 
{{(7,3), (0,0), (0,0)},
 {(2,0), (11,0), (0,0)},
 {(3,0), (5,0), (13,0)}}
--------------------------------------------------------------------
### SymmMatrix diag_vector member function as lvalue (lower)
### O.diag_vector(-2) += 10.0
mySymmMatrix O = 
{{(7,3), (0,0), (0,0)},
 {(2,0), (11,0), (0,0)},
 {(3,0), (5,0), (13,0)}}
Evaluating O.diag_vector(-2) += 10.0
Result: O = 
{{(7,3), (0,0), (0,0)},
 {(2,0), (11,0), (0,0)},
 {(13,0), (5,0), (13,0)}}
--------------------------------------------------------------------
### DiagMatrix diag_vector member function as lvalue
### D.diag_vector() = 0.0
myDiagMatrix D = 
{{(2,3), (0,0), (0,0)},
 {(0,0), (11,0), (0,0)},
 {(0,0), (0,0), (23,0)}}
Evaluating D.diag_vector() = 0.0
Result: D = 
{{(0,0), (0,0), (0,0)},
 {(0,0), (0,0), (0,0)},
 {(0,0), (0,0), (0,0)}}
--------------------------------------------------------------------
### DiagMatrix diag_vector member function incorrectly using offdiagonal
### D.diag_vector(1) = 0.0
myDiagMatrix D = 
{{(2,3), (0,0), (0,0)},
 {(0,0), (11,0), (0,0)},
 {(0,0), (0,0), (23,0)}}
Evaluating D.diag_vector(1) = 0.0
*** Failed with: Attempt to get lvalue diagonal to off-diagonal in BandMatrix (in ../include/adept/SpecialMatrix.h:350)
*** Correct behaviour
--------------------------------------------------------------------
### TridiagMatrix diag_vector member function as lvalue (upper)
### T.diag_vector(1) += 10.0
myTridiagMatrix T = 
{{(2,3), (3,0), (0,0)},
 {(7,4), (11,0), (13,0)},
 {(0,0), (19,0), (23,0)}}
Evaluating T.diag_vector(1) += 10.0
Result: T = 
{{(2,3), (13,0), (0,0)},
 {(7,4), (11,0), (23,0)},
 {(0,0), (19,0), (23,0)}}
--------------------------------------------------------------------
### TridiagMatrix diag_vector member function as lvalue (lower)
### T.diag_vector(-1) = 0.0
myTridiagMatrix T = 
{{(2,3), (3,0), (0,0)},
 {(7,4), (11,0), (13,0)},
 {(0,0), (19,0), (23,0)}}
Evaluating T.diag_vector(-1) = 0.0
Result: T = 
{{(2,3), (3,0), (0,0)},
 {(0,0), (11,0), (13,0)},
 {(0,0), (0,0), (23,0)}}
--------------------------------------------------------------------
### LowerMatrix diag_vector member function as lvalue (lower)
### L.diag_vector(-1) = 0.0
myLowerMatrix L = 
{{(2,3), (0,0), (0,0)},
 {(7,4), (11,0), (0,0)},
 {(17,0), (19,0), (23,0)}}
Evaluating L.diag_vector(-1) = 0.0
Result: L = 
{{(2,3), (0,0), (0,0)},
 {(0,0), (11,0), (0,0)},
 {(17,0), (0,0), (23,0)}}
--------------------------------------------------------------------
### LowerMatrix diag_vector member function as lvalue (upper)
### L.diag_vector(1) = 0.0
myLowerMatrix L = 
{{(2,3), (0,0), (0,0)},
 {(7,4), (11,0), (0,0)},
 {(17,0), (19,0), (23,0)}}
Evaluating L.diag_vector(1) = 0.0
*** Failed with: Attempt to get lvalue to an upper diagonal of a lower-triangular matrix (in ../include/adept/SpecialMatrix.h:683)
*** Correct behaviour
--------------------------------------------------------------------
### UpperMatrix diag_vector member function as lvalue (lower)
### U.diag_vector(-1) = 0.0
myUpperMatrix U = 
{{(2,3), (3,0), (5,0)},
 {(0,0), (11,0), (13,0)},
 {(0,0), (0,0), (23,0)}}
Evaluating U.diag_vector(-1) = 0.0
*** Failed with: Attempt to get lvalue to a lower diagonal of an upper-triangular matrix (in ../include/adept/SpecialMatrix.h:810)
*** Correct behaviour
--------------------------------------------------------------------
### UpperMatrix diag_vector member function as lvalue (upper)
### U.diag_vector(1) = 0.0
myUpperMatrix U = 
{{(2,3), (3,0), (5,0)},
 {(0,0), (11,0), (13,0)},
 {(0,0), (0,0), (23,0)}}
Evaluating U.diag_vector(1) = 0.0
Result: U = 
{{(2,3), (0,0), (5,0)},
 {(0,0), (11,0), (0,0)},
 {(0,0), (0,0), (23,0)}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(1) = -1.0
myOddBandMatrix Q = 
{{(3,0), (4,0), (0,0), (0,0), (0,0)},
 {(2,0), (3,0), (4,0), (0,0), (0,0)},
 {(1,0), (2,0), (3,0), (4,0), (0,0)},
 {(0,0), (1,0), (2,0), (3,0), (4,0)},
 {(0,0), (0,0), (1,0), (2,0), (3,0)}}
Evaluating Q.diag_vector(1) = -1.0
Result: Q = 
{{(3,0), (-1,0), (0,0), (0,0), (0,0)},
 {(2,0), (3,0), (-1,0), (0,0), (0,0)},
 {(1,0), (2,0), (3,0), (-1,0), (0,0)},
 {(0,0), (1,0), (2,0), (3,0), (-1,0)},
 {(0,0), (0,0), (1,0), (2,0), (3,0)}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(0) = -1.0
myOddBandMatrix Q = 
{{(3,0), (4,0), (0,0), (0,0), (0,0)},
 {(2,0), (3,0), (4,0), (0,0), (0,0)},
 {(1,0), (2,0), (3,0), (4,0), (0,0)},
 {(0,0), (1,0), (2,0), (3,0), (4,0)},
 {(0,0), (0,0), (1,0), (2,0), (3,0)}}
Evaluating Q.diag_vector(0) = -1.0
Result: Q = 
{{(-1,0), (4,0), (0,0), (0,0), (0,0)},
 {(2,0), (-1,0), (4,0), (0,0), (0,0)},
 {(1,0), (2,0), (-1,0), (4,0), (0,0)},
 {(0,0), (1,0), (2,0), (-1,0), (4,0)},
 {(0,0), (0,0), (1,0), (2,0), (-1,0)}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(-1) = -1.0
myOddBandMatrix Q = 
{{(3,0), (4,0), (0,0), (0,0), (0,0)},
 {(2,0), (3,0), (4,0), (0,0), (0,0)},
 {(1,0), (2,0), (3,0), (4,0), (0,0)},
 {(0,0), (1,0), (2,0), (3,0), (4,0)},
 {(0,0), (0,0), (1,0), (2,0), (3,0)}}
Evaluating Q.diag_vector(-1) = -1.0
Result: Q = 
{{(3,0), (4,0), (0,0), (0,0), (0,0)},
 {(-1,0), (3,0), (4,0), (0,0), (0,0)},
 {(1,0), (-1,0), (3,0), (4,0), (0,0)},
 {(0,0), (1,0), (-1,0), (3,0), (4,0)},
 {(0,0), (0,0), (1,0), (-1,0), (3,0)}}
--------------------------------------------------------------------
### Odd band matrix "diag_vector" member function
### Q.diag_vector(-2) = -1.0
myOddBandMatrix Q = 
{{(3,0), (4,0), (0,0), (0,0), (0,0)},
 {(2,0), (3,0), (4,0), (0,0), (0,0)},
 {(1,0), (2,0), (3,0), (4,0), (0,0)},
 {(0,0), (1,0), (2,0), (3,0), (4,0)},
 {(0,0), (0,0), (1,0), (2,0), (3,0)}}
Evaluating Q.diag_vector(-2) = -1.0
Result: Q = 
{{(3,0), (4,0), (0,0), (0,0), (0,0)},
 {(2,0), (3,0), (4,0), (0,0), (0,0)},
 {(-1,0), (2,0), (3,0), (4,0), (0,0)},
 {(0,0), (-1,0), (2,0), (3,0), (4,0)},
 {(0,0), (0,0), (-1,0), (2,0), (3,0)}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function
### M = S.submatrix_on_diagonal(1,2)
myMatrix M = (empty rank-2 array)
myMatrix S = 
{{(2,3), (3,0), (5,0)},
 {(7,4), (11,0), (13,0)},
 {(17,0), (19,0), (23,0)}}
Evaluating M = S.submatrix_on_diagonal(1,2)
Result: M = 
{{(11,0), (13,0)},
 {(19,0), (23,0)}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function as lvalue
### S.submatrix_on_diagonal(0,1) = 0.0
myMatrix S = 
{{(2,3), (3,0), (5,0)},
 {(7,4), (11,0), (13,0)},
 {(17,0), (19,0), (23,0)}}
Evaluating S.submatrix_on_diagonal(0,1) = 0.0
Result: S = 
{{(0,0), (0,0), (5,0)},
 {(0,0), (0,0), (13,0)},
 {(17,0), (19,0), (23,0)}}
--------------------------------------------------------------------
### Array submatrix_on_diagonal member function to non-square matrix
### M = N.submatrix_on_diagonal(1,2)
myMatrix M = (empty rank-2 array)
myMatrix N = 
{{(17,5), (19,0), (23,0)},
 {(29,0), (31,0), (37,0)}}
Evaluating M = N.submatrix_on_diagonal(1,2)
*** Failed with: submatrix_on_diagonal member function only applicable to square matrices (in ../include/adept/Array.h:1586)
*** Correct behaviour
--------------------------------------------------------------------
### SymmMatrix submatrix_on_diagonal member function
### P = O.submatrix_on_diagonal(1,2)
mySymmMatrix P = (empty rank-2 array)
mySymmMatrix O = 
{{(7,3), (0,0), (0,0)},
 {(2,0), (11,0), (0,0)},
 {(3,0), (5,0), (13,0)}}
Evaluating P = O.submatrix_on_diagonal(1,2)
Result: P = 
{{(11,0), (0,0)},
 {(5,0), (13,0)}}
--------------------------------------------------------------------
### DiagMatrix submatrix_on_diagonal member function
### E = D.submatrix_on_diagonal(1,2)
myDiagMatrix E = (empty rank-2 array)
myDiagMatrix D = 
{{(2,3), (0,0), (0,0)},
 {(0,0), (11,0), (0,0)},
 {(0,0), (0,0), (23,0)}}
Evaluating E = D.submatrix_on_diagonal(1,2)
Result: E = 
{{(11,0), (0,0)},
 {(0,0), (23,0)}}
--------------------------------------------------------------------
### TridiagMatrix submatrix_on_diagonal member function
### TT = T.submatrix_on_diagonal(1,2)
myTridiagMatrix TT = (empty rank-2 array)
myTridiagMatrix T = 
{{(2,3), (3,0), (0,0)},
 {(7,4), (11,0), (13,0)},
 {(0,0), (19,0), (23,0)}}
Evaluating TT = T.submatrix_on_diagonal(1,2)
Result: TT = 
{{(11,0), (13,0)},
 {(19,0), (23,0)}}
--------------------------------------------------------------------
### LowerMatrix submatrix_on_diagonal member function
### LL = L.submatrix_on_diagonal(1,2)
myLowerMatrix LL = (empty rank-2 array)
myLowerMatrix L = 
{{(2,3), (0,0), (0,0)},
 {(7,4), (11,0), (0,0)},
 {(17,0), (19,0), (23,0)}}
Evaluating LL = L.submatrix_on_diagonal(1,2)
Result: LL = 
{{(11,0), (0,0)},
 {(19,0), (23,0)}}
--------------------------------------------------------------------
### UpperMatrix submatrix_on_diagonal member function
### UU = U.submatrix_on_diagonal(1,2)
myUpperMatrix UU = (empty rank-2 array)
myUpperMatrix U = 
{{(2,3), (3,0), (5,0)},
 {(0,0), (11,0), (13,0)},
 {(0,0), (0,0), (23,0)}}
Evaluating UU = U.submatrix_on_diagonal(1,2)
Result: UU = 
{{(11,0), (13,0)},
 {(0,0), (23,0)}}
--------------------------------------------------------------------
### Odd band matrix submatrix_on_diagonal member function
### R = Q.submatrix_on_diagonal(1,3)
myOddBandMatrix R = (empty rank-2 array)
myOddBandMatrix Q = 
{{(3,0), (4,0), (0,0), (0,0), (0,0)},
 {(2,0), (3,0), (4,0), (0,0), (0,0)},
 {(1,0), (2,0), (3,0), (4,0), (0,0)},
 {(0,0), (1,0), (2,0), (3,0), (4,0)},
 {(0,0), (0,0), (1,0), (2,0), (3,0)}}
Evaluating R = Q.submatrix_on_diagonal(1,3)
Result: R = 
{{(3,0), (4,0), (0,0)},
 {(2,0), (3,0), (4,0)},
 {(1,0), (2,0), (3,0)}}
--------------------------------------------------------------------
### Odd band matrix submatrix_on_diagonal as lvalue
### Q.submatrix_on_diagonal(1,3) = -1
myOddBandMatrix Q = 
{{(3,0), (4,0), (0,0), (0,0), (0,0)},
 {(2,0), (3,0), (4,0), (0,0), (0,0)},
 {(1,0), (2,0), (3,0), (4,0), (0,0)},
 {(0,0), (1,0), (2,0), (3,0), (4,0)},
 {(0,0), (0,0), (1,0), (2,0), (3,0)}}
Evaluating Q.submatrix_on_diagonal(1,3) = -1
Result: Q = 
{{(3,0), (4,0), (0,0), (0,0), (0,0)},
 {(2,0), (-1,0), (-1,0), (0,0), (0,0)},
 {(1,0), (-1,0), (-1,0), (-1,0), (0,0)},
 {(0,0), (-1,0), (-1,0), (-1,0), (4,0)},
 {(0,0), (0,0), (1,0), (2,0), (3,0)}}
--------------------------------------------------------------------
### SymmMatrix transpose as rvalue via T member function
### P = O.T()
mySymmMatrix P = (empty rank-2 array)
mySymmMatrix O = 
{{(7,3), (0,0), (0,0)},
 {(2,0), (11,0), (0,0)},
 {(3,0), (5,0), (13,0)}}
Evaluating P = O.T()
Result: P = 
{{(7,3), (2,0), (3,0)},
 {(0,0), (11,0), (5,0)},
 {(0,0), (0,0), (13,0)}}
--------------------------------------------------------------------
### DiagMatrix transpose as rvalue via T member function
### E = D.T()
myDiagMatrix E = (empty rank-2 array)
myDiagMatrix D = 
{{(2,3), (0,0), (0,0)},
 {(0,0), (11,0), (0,0)},
 {(0,0), (0,0), (23,0)}}
Evaluating E = D.T()
Result: E = 
{{(2,3), (0,0), (0,0)},
 {(0,0), (11,0), (0,0)},
 {(0,0), (0,0), (23,0)}}
--------------------------------------------------------------------
### TridiagMatrix transpose as rvalue via T member function
### TT = T.T()
myTridiagMatrix TT = (empty rank-2 array)
myTridiagMatrix T = 
{{(2,3), (3,0), (0,0)},
 {(7,4), (11,0), (13,0)},
 {(0,0), (19,0), (23,0)}}
Evaluating TT = T.T()
Result: TT = 
{{(2,3), (7,4), (0,0)},
 {(3,0), (11,0), (19,0)},
 {(0,0), (13,0), (23,0)}}
--------------------------------------------------------------------
### LowerMatrix transpose as rvalue via T member function
### U = L.T()
myUpperMatrix U = (empty rank-2 array)
myLowerMatrix L = 
{{(2,3), (0,0), (0,0)},
 {(7,4), (11,0), (0,0)},
 {(17,0), (19,0), (23,0)}}
Evaluating U = L.T()
Result: U = 
{{(2,3), (7,4), (17,0)},
 {(0,0), (11,0), (19,0)},
 {(0,0), (0,0), (23,0)}}
--------------------------------------------------------------------
### UpperMatrix transpose as rvalue via T member function
### L = U.T()
myLowerMatrix L = (empty rank-2 array)
myUpperMatrix U = 
{{(2,3), (3,0), (5,0)},
 {(0,0), (11,0), (13,0)},
 {(0,0), (0,0), (23,0)}}
Evaluating L = U.T()
Result: L = 
{{(2,3), (0,0), (0,0)},
 {(3,0), (11,0), (0,0)},
 {(5,0), (13,0), (23,0)}}
====================================================================
   TESTING EXPANSION OPERATIONS
--------------------------------------------------------------------
### Outer product
### M = outer_product(v,v)
myMatrix M = (empty rank-2 array)
myVector v = {(2,3), (3,0), (5,0)}
Evaluating M = outer_product(v,v)
Result: M = 
{{(-5,12), (6,9), (10,15)},
 {(6,9), (9,0), (15,0)},
 {(10,15), (15,0), (25,0)}}
--------------------------------------------------------------------
### Outer product on indexed array
### M = outer_product(v,v(stride(end,0,-1)))
myMatrix M = (empty rank-2 array)
myVector v = {(2,3), (3,0), (5,0)}
Evaluating M = outer_product(v,v(stride(end,0,-1)))
Result: M = 
{{(10,15), (6,9), (-5,12)},
 {(15,0), (9,0), (6,9)},
 {(25,0), (15,0), (10,15)}}
--------------------------------------------------------------------
### Outer product on expressions
### M = outer_product(2.0*v,v-1.0)
myMatrix M = (empty rank-2 array)
myVector v = {(2,3), (3,0), (5,0)}
Evaluating M = outer_product(2.0*v,v-1.0)
Result: M = 
{{(-14,18), (8,12), (16,24)},
 {(6,18), (12,0), (24,0)},
 {(10,30), (20,0), (40,0)}}
--------------------------------------------------------------------
### Vector spread of dimension 0
### M = spread<0>(v,2)
myMatrix M = (empty rank-2 array)
myVector v = {(2,3), (3,0), (5,0)}
Evaluating M = spread<0>(v,2)
Result: M = 
{{(2,3), (3,0), (5,0)},
 {(2,3), (3,0), (5,0)}}
--------------------------------------------------------------------
### Vector spread of dimension 1
### M = spread<1>(v,2)
myMatrix M = (empty rank-2 array)
myVector v = {(2,3), (3,0), (5,0)}
Evaluating M = spread<1>(v,2)
Result: M = 
{{(2,3), (2,3)},
 {(3,0), (3,0)},
 {(5,0), (5,0)}}
--------------------------------------------------------------------
### Vector spread with expression argument
### M = spread<1>(v*2.0,2)
myMatrix M = (empty rank-2 array)
myVector v = {(2,3), (3,0), (5,0)}
Evaluating M = spread<1>(v*2.0,2)
Result: M = 
{{(4,6), (4,6)},
 {(6,0), (6,0)},
 {(10,0), (10,0)}}
--------------------------------------------------------------------
### Matrix spread of dimension 0
### A = spread<0>(M,2)
myArray3D A = (empty rank-3 array)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating A = spread<0>(M,2)
Result: A = 
{{{(2,3), (3,0), (5,0)},
  {(7,0), (11,0), (13,0)}},
 {{(2,3), (3,0), (5,0)},
  {(7,0), (11,0), (13,0)}}}
--------------------------------------------------------------------
### Matrix spread of dimension 1
### A = spread<1>(M,2)
myArray3D A = (empty rank-3 array)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating A = spread<1>(M,2)
Result: A = 
{{{(2,3), (3,0), (5,0)},
  {(2,3), (3,0), (5,0)}},
 {{(7,0), (11,0), (13,0)},
  {(7,0), (11,0), (13,0)}}}
--------------------------------------------------------------------
### Matrix spread of dimension 2
### A = spread<2>(M,2)
myArray3D A = (empty rank-3 array)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating A = spread<2>(M,2)
Result: A = 
{{{(2,3), (2,3)},
  {(3,0), (3,0)},
  {(5,0), (5,0)}},
 {{(7,0), (7,0)},
  {(11,0), (11,0)},
  {(13,0), (13,0)}}}
====================================================================
   TESTING FILLING ARRAYS
--------------------------------------------------------------------
### Fill vector with "<<"
### (v << 0.1, 0.2)
myVector v = {(2,3), (3,0), (5,0)}
Evaluating (v << 0.1, 0.2)
Result: v = {(0.1,0), (0.2,0), (5,0)}
--------------------------------------------------------------------
### Overfill vector with "<<"
### (v << 0.1, 0.2, 0.3, 0.4)
myVector v = {(2,3), (3,0), (5,0)}
Evaluating (v << 0.1, 0.2, 0.3, 0.4)
*** Failed with: Row overflow in filling Vector with "<<" (in ../include/adept/Allocator.h:132)
*** Correct behaviour
--------------------------------------------------------------------
### Underfill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5)
Result: M = 
{{(0.1,0), (0.2,0), (0.3,0)},
 {(0.4,0), (0.5,0), (13,0)}}
--------------------------------------------------------------------
### Fill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6)
Result: M = 
{{(0.1,0), (0.2,0), (0.3,0)},
 {(0.4,0), (0.5,0), (0.6,0)}}
--------------------------------------------------------------------
### Overfill matrix with "<<"
### (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating (M << 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
*** Failed with: Dimension overflow in filling array with "<<" (in ../include/adept/Allocator.h:154)
*** Correct behaviour
--------------------------------------------------------------------
### Fill vector with vectors using "<<"
### v << v(range(1,2)) << 0.1
myVector v = {(2,3), (3,0), (5,0)}
Evaluating v << v(range(1,2)) << 0.1
Result: v = {(3,0), (5,0), (0.1,0)}
--------------------------------------------------------------------
### Fill matrix with vector using "<<"
### M << 0.1 << 0.2 << 0.3 << v
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
myVector v = {(2,3), (3,0), (5,0)}
Evaluating M << 0.1 << 0.2 << 0.3 << v
Result: M = 
{{(0.1,0), (0.2,0), (0.3,0)},
 {(2,3), (3,0), (5,0)}}
--------------------------------------------------------------------
### Fill matrix with vector using "<<"
### S << v << v << v
myMatrix S = 
{{(2,3), (3,0), (5,0)},
 {(7,4), (11,0), (13,0)},
 {(17,0), (19,0), (23,0)}}
myVector v = {(2,3), (3,0), (5,0)}
Evaluating S << v << v << v
Result: S = 
{{(2,3), (3,0), (5,0)},
 {(2,3), (3,0), (5,0)},
 {(2,3), (3,0), (5,0)}}
--------------------------------------------------------------------
### Assign array using range
### v = range(3,6)
myVector v = (empty rank-1 array)
Evaluating v = range(3,6)
Result: v = {(3,0), (4,0), (5,0), (6,0)}
====================================================================
   TESTING PRINTING WITH PLAIN STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
(empty rank-1 array)
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
(2,3) (3,0) (5,0)
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'
(2,3) (3,0) (5,0)
(7,0) (11,0) (13,0)
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'
(2,3) (3,0)
(5,0) (7,0)
(11,0) (13,0)
(17,0) (19,0)
(23,0) (29,0)
(31,0) (37,0)
====================================================================
   TESTING PRINTING WITH CSV STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
empty
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
(2,3), (3,0), (5,0)
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'
(2,3), (3,0), (5,0)
(7,0), (11,0), (13,0)
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'
(2,3), (3,0)
(5,0), (7,0)
(11,0), (13,0)
(17,0), (19,0)
(23,0), (29,0)
(31,0), (37,0)
====================================================================
   TESTING PRINTING WITH CURLY STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
(empty rank-1 array)
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
{(2,3), (3,0), (5,0)}
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'

{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'

{{{(2,3), (3,0)},
  {(5,0), (7,0)},
  {(11,0), (13,0)}},
 {{(17,0), (19,0)},
  {(23,0), (29,0)},
  {(31,0), (37,0)}}}
====================================================================
   TESTING PRINTING WITH MATLAB STYLE
--------------------------------------------------------------------
### Printing empty vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
[]
--------------------------------------------------------------------
### Printing vector
### std::cout << v << '\n'
Evaluating std::cout << v << '\n'
[(2,3) (3,0) (5,0)]
--------------------------------------------------------------------
### Printing matrix
### std::cout << M << '\n'
Evaluating std::cout << M << '\n'
[(2,3) (3,0) (5,0);
 (7,0) (11,0) (13,0)]
--------------------------------------------------------------------
### Printing 3D array
### std::cout << A << '\n'
Evaluating std::cout << A << '\n'
[(2,3) (3,0);
 (5,0) (7,0);
 (11,0) (13,0);
 (17,0) (19,0);
 (23,0) (29,0);
 (31,0) (37,0)]
====================================================================
   TESTING EXPRESSION PRINTING
--------------------------------------------------------------------
### Send expression to standard output
### std::cout << M(0,__) + M(1,__) << '\n'
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating std::cout << M(0,__) + M(1,__) << '\n'
{(9,3), (14,0), (18,0)}
Result: M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
--------------------------------------------------------------------
### Send scalar expression to standard output
### std::cout << v(0) + v(1) << '\n'
myVector v = {(2,3), (3,0), (5,0)}
Evaluating std::cout << v(0) + v(1) << '\n'
(5,3)
Result: v = {(2,3), (3,0), (5,0)}
====================================================================
   TESTING BOUNDS CHECKING
--------------------------------------------------------------------
### Access vector out of bounds
### v(0) = v(4)
myVector v = {(2,3), (3,0), (5,0)}
Evaluating v(0) = v(4)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Access vector out of bounds
### v(0) = v(end-4)
myVector v = {(2,3), (3,0), (5,0)}
Evaluating v(0) = v(end-4)
*** Failed with: Array index (probably generated from a scalar expression containing "end") is out of bounds (in ../include/adept/RangeIndex.h:128)
*** Correct behaviour
--------------------------------------------------------------------
### Access matrix out of bounds
### M(0,0) = M(0,-1)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating M(0,0) = M(0,-1)
*** Failed with: Array index is out of bounds
*** Correct behaviour
--------------------------------------------------------------------
### Access matrix out of bounds
### M(0,0) = M(end+1,1)
myMatrix M = 
{{(2,3), (3,0), (5,0)},
 {(7,0), (11,0), (13,0)}}
Evaluating M(0,0) = M(end+1,1)
*** Failed with: Array index (probably generated from a scalar expression containing "end") is out of bounds (in ../include/adept/RangeIndex.h:128)
*** Correct behaviour
====================================================================
In terms of run-time errors, all tests were passed
